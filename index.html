<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passenger Princess Protector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        .font-dancing {
            font-family: 'Dancing Script', cursive;
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        /* Full screen map */
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: calc(100vh - 60px);
            width: 100vw;
            position: absolute;
            top: 60px;
            margin: 0;
            padding: 0;
        }

        /* Overlay form at bottom */
        .overlay-form {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Top results area */
        .bottom-results {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 1100;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
            height: calc(100vh - 60px);
        }

        /* Compact table styling */
        #chargers-table {
            border-collapse: collapse;
            line-height: 1;
            height: auto;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            width: 100%;
        }

        #chargers-table tr,
        #chargers-table tr td,
        #chargers-table tr th {
            height: 18px !important;
            line-height: 1 !important;
        }

        #chargers-table td,
        #chargers-table th {
            border-bottom: 1px solid #fbcfe8;
            /* pink-200 */
        }

        /* Compact list items */
        .compact-charger-item {
            margin-bottom: 8px !important;
            padding: 8px !important;
            border-radius: 6px;
            background: white;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .compact-charger-item h3 {
            font-size: 14px !important;
            margin-bottom: 4px !important;
            font-weight: 600;
        }

        .compact-charger-item p {
            font-size: 12px !important;
            margin-bottom: 2px !important;
            line-height: 1.3;
        }

        .compact-charger-item h4 {
            font-size: 13px !important;
            margin-bottom: 4px !important;
            font-weight: 600;
        }

        .compact-charger-item ul {
            margin: 0;
            padding: 0;
        }

        .compact-charger-item li {
            font-size: 11px !important;
            margin-bottom: 2px !important;
            line-height: 1.2;
        }

        /* Custom scrollbar for the results list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Table styles */
        #chargers-table {
            table-layout: fixed;
        }

        #chargers-table td {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .overlay-form {
                padding: 10px;
                position: fixed;
                top: 0;
            }

            .bottom-results {
                padding: 0;
            }

            .compact-charger-item {
                margin-bottom: 6px !important;
                padding: 6px !important;
            }

            .drag-handle {
                width: 50px;
                height: 5px;
            }

            .show-list-bottom {
                padding: 6px 10px;
                font-size: 11px;
            }

            /* Table responsive design */
            #chargers-table {
                font-size: 10px;
            }

            #chargers-table th,
            #chargers-table td {
                padding: 4px 6px;
            }

            #chargers-table th:nth-child(1),
            #chargers-table td:nth-child(1) {
                width: 80px;
            }

            #chargers-table th:nth-child(2),
            #chargers-table td:nth-child(2) {
                width: 120px;
            }

            #chargers-table th:nth-child(3),
            #chargers-table td:nth-child(3) {
                width: 60px;
            }

            #chargers-table th:nth-child(4),
            #chargers-table td:nth-child(4) {
                width: 90px;
            }

            #chargers-table th:nth-child(5),
            #chargers-table td:nth-child(5) {
                width: 160px;
            }
        }

        .autocomplete-suggestions {
            position: fixed;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1100;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 2px;
        }

        .autocomplete-suggestion {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.15s ease-in-out;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestion:hover {
            background: #f8fafc;
        }

        /* Enhanced link styling for clickable results */
        .city-link,
        .restaurant-link {
            text-decoration: underline;
            text-decoration-color: rgba(236, 72, 153, 0.5);
            text-underline-offset: 2px;
        }

        .city-link:hover,
        .restaurant-link:hover {
            text-decoration-color: rgb(236, 72, 153);
        }

        /* Custom emoji icons for map markers */
        .emoji-icon {
            font-size: 24px;
            line-height: 1;
            text-align: center;
            /* Simple shadow for better visibility */
            text-shadow: 0 0 3px white, 0 0 5px white;
        }

        /* Search highlight styling */
        mark {
            background-color: #fef3c7 !important;
            color: #000 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-weight: 600 !important;
        }

        /* Loading spinner styles */
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #ec4899;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #cuisine-filter-buttons button.selected {
            background-color: #ec4899;
            /* pink-500 */
            color: white;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }

        /* Hide table headers when loading */
        #loading-container:not(.hidden)~#chargers-table thead {
            display: none;
        }

        #cuisine-filter-buttons button.selected {
            background-color: #ec4899;
            /* pink-500 */
            color: white;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }

        /* Princess marker styling */
        .princess-marker {
            background: transparent !important;
            border: none !important;
            font-size: 36px !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Location tracking button styling */
        #location-btn.tracking-active {
            background: linear-gradient(to-r, #ec4899, #f97316);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }
    </style>
</head>

<body class="bg-pink-100 font-sans antialiased">
    <div id="map"></div>

    <div id="top-toolbar"
        class="fixed top-0 left-0 right-0 z-50 bg-gradient-to-r from-pink-200 to-pink-300 border-b border-pink-400 p-3 flex justify-between items-center shadow-lg">
        <div class="text-2xl font-bold text-pink-800 font-dancing">PPP</div>
        <div class="flex space-x-2">
            <button id="gps-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-3 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200 hidden"
                title="Center on Princess">üìç</button>
            <button id="toggle-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200">Show
                Results</button>
            <button id="new-search-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200">New
                Search</button>
        </div>
    </div>

    <div class="bottom-results" id="bottom-results">
        <div id="results-list" class="custom-scrollbar px-2" style="height: 100%; overflow-y: auto;">
            <div class="flex space-x-2 mb-4 pt-4">
                <input type="text" id="restaurant-search"
                    class="flex-grow px-4 py-3 border border-pink-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-pink-500 text-sm enhanced-input"
                    placeholder="Search restaurants or cuisines...">
                <button id="toggle-cuisine-btn"
                    class="px-3 py-3 bg-pink-400 hover:bg-pink-500 text-white rounded-md shadow-sm text-sm"
                    title="Toggle cuisine filters">Filters</button>
            </div>
            <div id="cuisine-filter-buttons" class="flex flex-wrap gap-2 mb-4" style="display: none;">
                <!-- Cuisine buttons will be dynamically inserted here -->
            </div>

            <div id="loading-container" class="loading-container hidden">
                <div class="spinner"></div>
                <p class="loading-text" id="loading-text">Retrieving superchargers...</p>
            </div>

            <div style="overflow-x: auto;">
                <table id="chargers-table" class="hidden">
                    <thead class="sticky top-0 bg-white z-10">
                        <tr>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-20">
                                Charger
                            </th>
                            <th class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider">
                                Restaurant
                            </th>
                            <th class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider">
                                Walk
                            </th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-24">
                                Cuisine
                            </th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-48">
                                Opening Hours
                            </th>
                        </tr>
                    </thead>
                    <tbody id="chargers-tbody">
                    </tbody>
                </table>
            </div>
            <p id="no-results" class="text-pink-500">Search for a route to see results.</p>
        </div>
        <hr class="border-pink-300">
    </div>

    <div class="overlay-form" id="search-form">
        <header class="text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold text-pink-800 font-dancing">Passenger Princess Protector</h1>
        </header>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-end">
            <div class="relative">
                <div class="flex items-center justify-between mb-1">
                    <label for="origin" class="block text-sm font-medium text-pink-700">Origin</label>
                    <button id="location-btn"
                        class="bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white px-3 py-1 rounded-md text-xs font-medium focus:outline-none disabled:opacity-50 whitespace-nowrap shadow-md hover:shadow-lg transition-all duration-200">
                        <span id="location-text">üë∏ Use Current Location</span>
                        <div id="loading-spinner"
                            class="hidden w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin inline-block ml-2">
                        </div>
                    </button>
                </div>
                <input type="text" id="origin"
                    class="block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm enhanced-input"
                    placeholder="e.g., San Francisco, CA">
                <div id="origin-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="relative">
                <label for="destination" class="block text-sm font-medium text-pink-700">Destination</label>
                <input type="text" id="destination"
                    class="mt-1 block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm enhanced-input"
                    placeholder="e.g., Los Angeles, CA">
                <div id="destination-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="md:col-span-2">
                <button id="find-route-btn"
                    class="w-full bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all duration-200 text-sm hover:shadow-lg">
                    Find Route & Amenities
                </button>
            </div>
        </div>
        <div id="status-message" class="text-center mt-3 text-pink-600 font-medium text-sm"></div>
    </div>

    <div id="new-search-modal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[1200] hidden">
        <div class="bg-white rounded-lg p-6 max-w-sm mx-4 shadow-xl">
            <h3 class="text-lg font-semibold text-pink-800 mb-4 font-dancing">Are you sure?</h3>
            <p class="text-gray-600 mb-6">This will clear your current search and start a new one.</p>
            <div class="flex space-x-3 justify-end">
                <button id="cancel-new-search"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium">Cancel</button>
                <button id="confirm-new-search"
                    class="px-4 py-2 bg-pink-500 hover:bg-pink-600 text-white rounded-lg font-medium">Yes, New
                    Search</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const ORS_API_KEY = 'YOUR_OPENROUTESERVICE_API_KEY' // IMPORTANT: Get your free API key from https://openrouteservice.org/

        const SEARCH_RADIUS_MILES = 5

        // --- DOM ELEMENTS ---
        const originInput = document.getElementById( 'origin' )
        const destinationInput = document.getElementById( 'destination' )
        const findRouteBtn = document.getElementById( 'find-route-btn' )
        const statusMessage = document.getElementById( 'status-message' )
        const mapElement = document.getElementById( 'map' )
        const originSuggestions = document.getElementById( 'origin-suggestions' )
        const destinationSuggestions = document.getElementById( 'destination-suggestions' )
        const searchForm = document.getElementById( 'search-form' )
        const bottomResults = document.getElementById( 'bottom-results' )
        const topToolbar = document.getElementById( 'top-toolbar' )
        const newSearchBtn = document.getElementById( 'new-search-btn' )
        const locationBtn = document.getElementById( 'location-btn' )
        const locationText = document.getElementById( 'location-text' )
        const loadingSpinner = document.getElementById( 'loading-spinner' )
        const restaurantSearchInput = document.getElementById( 'restaurant-search' )
        const cuisineFilterButtons = document.getElementById( 'cuisine-filter-buttons' )


        // Initially hide the top toolbar and adjust map position since search form is visible
        topToolbar.style.display = 'none'
        mapElement.style.top = '0'
        mapElement.style.height = '100vh'

        // --- MAP INITIALIZATION ---
        let map = L.map( mapElement, {
            zoomControl: false,
            zoomSnap: 0.5,
            zoomDelta: 1
        } ).setView( [ 37.7749, -122.4194 ], 6 ) // Default to SF
        L.tileLayer( 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        } ).addTo( map )

        // Map Layers
        const routeLayer = L.layerGroup().addTo( map )
        const chargerLayer = L.layerGroup().addTo( map )
        const restaurantLayer = L.layerGroup().addTo( map )
        const userLocationLayer = L.layerGroup().addTo( map )

        // --- STATE MANAGEMENT ---
        let userLocationMarker = null
        let locationTrackingInterval = null
        // The single source of truth for all station data.
        // Each object contains all info: charger data, restaurant data, and map markers.
        let stationData = []
        // Tracks the current filter state. `null` means no filter, an array of IDs means filter is active.
        let filteredChargerIDs = null
        let currentSearchTerm = ''
        let currentCuisineFilter = []


        // --- EVENT LISTENERS ---
        findRouteBtn.addEventListener( 'click', handleRouteSearch )
        locationBtn.addEventListener( 'click', handleLocationClick )
        restaurantSearchInput.addEventListener( 'input', () => {
            filterListAndMap( restaurantSearchInput.value, currentCuisineFilter )
        } )
        cuisineFilterButtons.addEventListener( 'click', ( e ) => {
            if ( e.target.tagName === 'BUTTON' ) {
                const cuisine = e.target.dataset.cuisine

                // Toggle selection
                if ( currentCuisineFilter.includes( cuisine ) ) {
                    currentCuisineFilter = currentCuisineFilter.filter( c => c !== cuisine )
                    e.target.classList.remove( 'selected' )
                } else {
                    currentCuisineFilter.push( cuisine )
                    e.target.classList.add( 'selected' )
                }

                // If 'All' is clicked, deselect others
                if ( cuisine === '' && e.target.classList.contains( 'selected' ) ) {
                    currentCuisineFilter = [ '' ]
                    // Visually deselect other buttons
                    Array.from( cuisineFilterButtons.children ).forEach( btn => {
                        if ( btn !== e.target ) btn.classList.remove( 'selected' )
                    } )
                } else if ( cuisine !== '' ) {
                    // If another button is clicked, deselect 'All'
                    const allButton = cuisineFilterButtons.querySelector( 'button[data-cuisine=""]' )
                    if ( allButton ) {
                        allButton.classList.remove( 'selected' )
                        currentCuisineFilter = currentCuisineFilter.filter( c => c !== '' )
                    }
                }

                // If nothing is selected, select 'All'
                if ( currentCuisineFilter.length === 0 ) {
                    const allButton = cuisineFilterButtons.querySelector( 'button[data-cuisine=""]' )
                    if ( allButton ) {
                        allButton.classList.add( 'selected' )
                        currentCuisineFilter = [ '' ]
                    }
                }

                filterListAndMap( currentSearchTerm, currentCuisineFilter.filter( c => c !== '' ) )
            }
        } )

        // Update map markers when the user pans or zooms
        map.on( 'moveend zoomend', updateVisibleMarkers );

        // --- AUTO-SEARCH FROM URL PARAMS ---
        ( function autoSearchFromUrl () {
            const urlParams = new URLSearchParams( window.location.search )
            const originParam = urlParams.get( 'origin' )
            const destinationParam = urlParams.get( 'destination' )
            if ( originParam && destinationParam ) {
                originInput.value = decodeURIComponent( originParam )
                destinationInput.value = decodeURIComponent( destinationParam )
                setTimeout( () => handleRouteSearch(), 500 )
            }
        } )()

        // --- CORE APPLICATION LOGIC ---

        /**
         * Main function to handle the entire search process.
         */
        async function handleRouteSearch () {
            const origin = originInput.value.trim()
            const destination = destinationInput.value.trim()

            if ( !origin || !destination ) {
                updateStatus( "Please enter both an origin and a destination.", true )
                return
            }
            if ( ORS_API_KEY === 'YOUR_OPENROUTESERVICE_API_KEY' ) {
                updateStatus( "Please add your OpenRouteService API key to the script.", true )
                alert( "API Key missing. Please edit the HTML file and add your free API key from openrouteservice.org." )
                return
            }

            // Update URL and UI for search start
            updateUrlForSearch( origin, destination )
            clearPreviousResults()
            showLoadingState( "Finding route..." )

            try {
                // Step 1: Geocode addresses to get coordinates
                const [ originCoords, destCoords ] = await Promise.all( [
                    geocodeAddress( origin ),
                    geocodeAddress( destination )
                ] )
                if ( !originCoords || !destCoords ) {
                    throw new Error( "Could not find one or both locations. Please be more specific." )
                }

                // Step 2: Fetch and draw the route
                showLoadingState( "Calculating route..." )
                const routeData = await getRoute( originCoords, destCoords )
                const routeCoords = routeData.geometry.coordinates.map( c => [ c[ 1 ], c[ 0 ] ] )
                drawRoute( routeCoords )
                map.fitBounds( L.polyline( routeCoords ).getBounds().pad( 0.1 ) )

                // Step 3: Find chargers along the route
                showLoadingState( "Retrieving superchargers..." )
                const allChargers = await getSuperchargers( routeCoords )
                const chargersOnRoute = findChargersNearRoute( allChargers, routeCoords, SEARCH_RADIUS_MILES )

                // Step 4: Fetch restaurants and build the final data structure
                showLoadingState( "Retrieving restaurants..." )
                await processAndDisplayResults( chargersOnRoute, originCoords )

                updateStatus( `Found ${ stationData.length } Superchargers with restaurants.`, false )

            } catch ( error ) {
                console.error( "Error during route search:", error )
                const userMessage = error.message.includes( "routable point" ) ?
                    "Could not find a route. Please try a different or more specific location." :
                    "An error occurred. Please check your locations and try again."
                showErrorState( userMessage )
            }
        }

        /**
         * Takes chargers, fetches restaurants, sorts, and builds the UI.
         * This function creates the master `stationData` array.
         */
        async function processAndDisplayResults ( chargers, originCoords ) {
            if ( chargers.length === 0 ) {
                showEmptyState( "No Superchargers found near your route." )
                return
            }

            // Fetch restaurants for all chargers in a single batch
            const locations = chargers.map( c => c.gps )
            const restaurantResults = await getNearbyRestaurantsBulk( locations )

            // Combine chargers with their restaurants
            let combinedData = chargers.map( ( charger, index ) => ( {
                charger,
                restaurants: restaurantResults[ index ]?.restaurants || []
            } ) )

            // Sort by distance from the trip's origin
            combinedData.sort( ( a, b ) => {
                const distA = distance( originCoords[ 1 ], originCoords[ 0 ], a.charger.gps.latitude, a.charger.gps.longitude )
                const distB = distance( originCoords[ 1 ], originCoords[ 0 ], b.charger.gps.latitude, b.charger.gps.longitude )
                return distA - distB
            } )

            // Reset state and build the new `stationData` and table UI
            stationData = []
            const tbody = document.getElementById( 'chargers-tbody' )
            tbody.innerHTML = ''
            const fragment = document.createDocumentFragment()

            combinedData.forEach( ( { charger, restaurants } ) => {
                // Create map markers for this station
                const chargerMarker = createChargerMarker( charger, restaurants, originCoords )
                const restaurantMarkers = createRestaurantMarkers( restaurants )

                // Add the complete station object to our master data array
                stationData.push( {
                    id: charger.id.toString(), // Use ID as a string for consistency
                    chargerInfo: charger,
                    restaurants: restaurants,
                    chargerMarker: chargerMarker,
                    restaurantMarkers: restaurantMarkers,
                } )

                // Create and append the table row(s) for this station to the document fragment
                const tableRows = createTableRowsForStation( charger, restaurants, originCoords )
                tableRows.forEach( row => fragment.appendChild( row ) )
            } )

            tbody.appendChild( fragment )
            populateCuisineFilter()
            showResultsTable()
            updateVisibleMarkers() // Initial map update
        }

        /**
         * Filters the visible list items and updates the map markers based on a search term.
         */
        function filterListAndMap ( searchTerm, cuisines ) {
            currentSearchTerm = searchTerm.toLowerCase()
            currentCuisineFilter = Array.isArray( cuisines ) ? cuisines.map( c => c.toLowerCase() ) : ( cuisines ? [ cuisines.toLowerCase() ] : [] )

            const tbody = document.getElementById( 'chargers-tbody' )
            if ( !tbody ) return

            const rows = tbody.querySelectorAll( 'tr[data-charger-id]' )
            let chargerVisibility = new Map() // chargerId => { visible: bool, hasRestaurants: bool }

            // First pass: determine visibility per charger
            rows.forEach( row => {
                const chargerId = row.dataset.chargerId
                const restaurantCell = row.querySelector( '.restaurant-link' )

                if ( !chargerVisibility.has( chargerId ) ) {
                    chargerVisibility.set( chargerId, { visible: false, hasRestaurants: false } )
                }

                if ( restaurantCell ) {
                    chargerVisibility.get( chargerId ).hasRestaurants = true
                    const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
                    const restaurantName = restaurantCell.textContent
                    const originalCuisineText = cuisineCell.dataset.originalCuisine || cuisineCell.textContent
                    if ( !cuisineCell.dataset.originalCuisine ) {
                        cuisineCell.dataset.originalCuisine = originalCuisineText
                    }

                    const nameMatches = !currentSearchTerm || restaurantName.toLowerCase().includes( currentSearchTerm )
                    const restaurantCuisines = originalCuisineText.toLowerCase().split( ';' ).map( c => c.trim() )
                    const cuisineMatches = currentCuisineFilter.length === 0 || currentCuisineFilter.includes( '' ) || currentCuisineFilter.some( filterCuisine => filterCuisine !== '' && restaurantCuisines.includes( filterCuisine ) )

                    if ( nameMatches && cuisineMatches ) {
                        chargerVisibility.get( chargerId ).visible = true
                    }
                } else { // No restaurants row
                    if ( !currentSearchTerm && ( currentCuisineFilter.length === 0 || currentCuisineFilter.includes( '' ) ) ) {
                        chargerVisibility.get( chargerId ).visible = true
                    }
                }
            } )

            // Second pass: show/hide rows and highlight
            let visibleChargerIDs = new Set()
            rows.forEach( row => {
                const chargerId = row.dataset.chargerId
                const visibility = chargerVisibility.get( chargerId )
                const restaurantCell = row.querySelector( '.restaurant-link' )

                if ( visibility.visible ) {
                    row.style.display = ''
                    visibleChargerIDs.add( chargerId )

                    if ( restaurantCell ) {
                        const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
                        const restaurantName = restaurantCell.textContent
                        const originalCuisineText = cuisineCell.dataset.originalCuisine || cuisineCell.textContent

                        // Highlight restaurant name
                        restaurantCell.innerHTML = currentSearchTerm ?
                            restaurantName.replace( new RegExp( `(${ searchTerm })`, 'gi' ), '<mark>$1</mark>' ) :
                            restaurantName

                        // Highlight cuisine
                        let highlightedCuisine = originalCuisineText
                        if ( currentCuisineFilter.length > 0 ) {
                            const restaurantCuisines = originalCuisineText.toLowerCase().split( ';' ).map( c => c.trim() )
                            const matchedCuisines = restaurantCuisines.filter( rc => currentCuisineFilter.includes( rc ) )
                            if ( matchedCuisines.length > 0 ) {
                                highlightedCuisine = originalCuisineText.replace( new RegExp( `(${ matchedCuisines.join( '|' ) })`, 'gi' ), '<mark>$1</mark>' )
                            }
                        }
                        cuisineCell.innerHTML = highlightedCuisine
                    }
                } else {
                    row.style.display = 'none'
                    if ( restaurantCell ) {
                        const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
                        const restaurantName = restaurantCell.textContent
                        const originalCuisineText = cuisineCell.dataset.originalCuisine || cuisineCell.textContent
                        restaurantCell.innerHTML = restaurantName
                        cuisineCell.innerHTML = originalCuisineText
                    }
                }
            } )

            // Update the global filter state for map markers
            if ( !currentSearchTerm && currentCuisineFilter.length === 0 ) {
                filteredChargerIDs = null
            } else {
                filteredChargerIDs = Array.from( visibleChargerIDs )
            }

            updateVisibleMarkers() // Trigger map update with new filter state
        }


        // --- MAP AND MARKER FUNCTIONS ---

        /**
         * The single source of truth for showing/hiding markers on the map.
         * It checks the map bounds and the current filter state.
         */
        function updateVisibleMarkers () {
            const bounds = map.getBounds()
            const zoom = map.getZoom()

            stationData.forEach( station => {
                const chargerShouldBeVisible = filteredChargerIDs === null || filteredChargerIDs.includes( station.id )
                const chargerMarker = station.chargerMarker

                // Update charger marker
                if ( chargerShouldBeVisible && bounds.contains( chargerMarker.getLatLng() ) ) {
                    if ( !chargerLayer.hasLayer( chargerMarker ) ) chargerLayer.addLayer( chargerMarker )
                } else {
                    if ( chargerLayer.hasLayer( chargerMarker ) ) chargerLayer.removeLayer( chargerMarker )
                }

                // Update restaurant markers (only if charger is visible and zoomed in)
                const restaurantsShouldBeVisible = chargerShouldBeVisible && zoom >= 14
                station.restaurantMarkers.forEach( restaurantMarker => {
                    const nameMatches = !currentSearchTerm || restaurantMarker.options.restaurantName.toLowerCase().includes( currentSearchTerm )
                    const restaurantCuisines = ( restaurantMarker.options.cuisine || '' ).toLowerCase().split( ';' ).map( c => c.trim() )
                    const cuisineMatches = currentCuisineFilter.length === 0 || currentCuisineFilter.includes( '' ) || currentCuisineFilter.some( fc => fc !== '' && restaurantCuisines.includes( fc.toLowerCase() ) )

                    if ( restaurantsShouldBeVisible && nameMatches && cuisineMatches && bounds.contains( restaurantMarker.getLatLng() ) ) {
                        if ( !restaurantLayer.hasLayer( restaurantMarker ) ) restaurantLayer.addLayer( restaurantMarker )
                    } else {
                        if ( restaurantLayer.hasLayer( restaurantMarker ) ) restaurantLayer.removeLayer( restaurantMarker )
                    }
                } )
            } )
        }

        function createChargerMarker ( charger, restaurants, originCoords ) {
            let distanceFromOrigin = 'N/A'
            if ( originCoords ) {
                distanceFromOrigin = distance( originCoords[ 1 ], originCoords[ 0 ], charger.gps.latitude, charger.gps.longitude ).toFixed( 1 ) + ' mi'
            }

            const address = [ charger.address.street, charger.address.city, charger.address.state ].filter( Boolean ).join( ', ' )

            let popupContent = `
                <div class="font-sans max-w-xs">
                    <strong class="text-lg">${ charger.name }</strong><br>
                    <strong>Address:</strong> ${ address }<br>
                    <strong>Stalls:</strong> ${ charger.stallCount }<br>
                    <strong>Distance:</strong> ${ distanceFromOrigin }<br>
                    <button onclick="showChargerInResults('${ charger.id }')" class="bg-pink-500 hover:bg-pink-600 text-white text-sm px-2 py-1 rounded mt-2 mr-2">View in Results</button>
                    <a href="https://maps.google.com/?q=${ charger.gps.latitude },${ charger.gps.longitude }" target="_blank" class="text-pink-500 hover:underline text-sm">Open in Google Maps</a>
                `

            if ( restaurants.length > 0 ) {
                popupContent += '<br><br><strong>Nearby Restaurants:</strong><br>'
                popupContent += restaurants.slice( 0, 5 ).map( r => `<div class="text-sm mt-1">‚Ä¢ ${ r.name } (${ r.distance }m)</div>` ).join( '' )
                if ( restaurants.length > 5 ) popupContent += `<div class="text-sm mt-1 text-black">and ${ restaurants.length - 5 } more...</div>`
            }
            popupContent += '</div>'

            return L.marker( [ charger.gps.latitude, charger.gps.longitude ], {
                icon: L.divIcon( {
                    className: 'emoji-icon',
                    html: '‚ö°Ô∏è',
                    iconSize: [ 24, 24 ],
                } )
            } ).bindPopup( popupContent )
        }

        function createRestaurantMarkers ( restaurants ) {
            return restaurants.map( restaurant => {
                return L.marker( [ restaurant.gps.latitude, restaurant.gps.longitude ], {
                    icon: L.divIcon( {
                        className: 'emoji-icon',
                        html: 'üå≠',
                        iconSize: [ 24, 24 ],
                    } ),
                    restaurantName: restaurant.name, // Store for filtering
                    cuisine: restaurant.cuisine
                } ).bindPopup( `<strong>${ restaurant.name }</strong><br>${ restaurant.distance }m away` )
            } )
        }

        function drawRoute ( coords ) {
            L.polyline( coords, {
                color: 'hotpink',
                weight: 5,
                opacity: 0.7
            } ).addTo( routeLayer )
        }

        // --- UI AND DOM MANIPULATION ---

        function createTableRowsForStation ( charger, restaurants, originCoords ) {
            const rows = []
            let distanceFromOrigin = 'N/A'
            if ( originCoords ) {
                distanceFromOrigin = distance( originCoords[ 1 ], originCoords[ 0 ], charger.gps.latitude, charger.gps.longitude ).toFixed( 1 ) + ' mi'
            }
            const address = [ charger.address.street, charger.address.city, charger.address.state ].filter( Boolean ).join( ', ' )

            const chargerCell = `
                <td class="px-1 py-0 text-sm text-pink-500 border-r border-pink-200" rowspan="${ restaurants.length || 1 }">
                    <div class="flex flex-col">
                        <span>${ distanceFromOrigin }</span>
                        <span class="text-xs text-pink-600 hover:text-pink-800 cursor-pointer city-link">${ address || charger.name }</span>
                    </div>
                </td>
            `

            if ( restaurants.length === 0 ) {
                const row = document.createElement( 'tr' )
                row.dataset.chargerId = charger.id.toString()
                row.innerHTML = `
                    ${ chargerCell }
                    <td class="px-1 py-0 text-sm text-pink-700" colspan="4">No restaurants found</td>
                `
                rows.push( row )
            } else {
                restaurants.forEach( ( restaurant, index ) => {
                    const row = document.createElement( 'tr' )
                    row.dataset.chargerId = charger.id.toString()
                    row.dataset.restaurantId = restaurant.id

                    const restaurantContent = `
                        <td class="px-1 py-0 text-sm text-pink-700">
                            <span class="text-pink-600 hover:text-pink-800 cursor-pointer restaurant-link">${ restaurant.name }</span>
                        </td>
                        <td class="px-1 py-0 text-sm text-pink-700">${ restaurant.distance }m</td>
                        <td class="px-1 py-0 text-sm text-pink-700" data-original-cuisine="${ restaurant.cuisine }">${ restaurant.cuisine }</td>
                        <td class="px-1 py-0 text-sm text-pink-700" style="white-space: pre-wrap; word-break: break-all;">${ restaurant.opening_hours }</td>
                    `

                    if ( index === 0 ) {
                        row.innerHTML = `
                            ${ chargerCell }
                            ${ restaurantContent }
                        `
                    } else {
                        row.innerHTML = restaurantContent
                    }
                    rows.push( row )
                } )
            }

            addClickHandlersToRows( rows, charger )
            return rows
        }

        function addClickHandlersToRows ( rows, charger ) {
            rows.forEach( row => {
                row.querySelector( '.city-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const station = stationData.find( s => s.id === charger.id.toString() )
                    if ( station ) {
                        map.setView( station.chargerMarker.getLatLng(), 15 )
                        station.chargerMarker.openPopup()
                        bottomResults.style.display = 'none'
                        document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                    }
                } )

                row.querySelector( '.restaurant-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const restaurantName = e.target.textContent
                    const station = stationData.find( s => s.id === charger.id.toString() )
                    if ( station ) {
                        const restaurantMarker = station.restaurantMarkers.find( m => m.options.restaurantName === restaurantName )
                        if ( restaurantMarker ) {
                            map.setView( restaurantMarker.getLatLng(), 16 )
                            restaurantMarker.openPopup()
                            bottomResults.style.display = 'none'
                            document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                        }
                    }
                } )
            } )
        }

        function populateCuisineFilter () {
            const cuisines = new Set()
            stationData.forEach( station => {
                station.restaurants.forEach( r => {
                    if ( r.cuisine && r.cuisine !== 'N/A' ) {
                        r.cuisine.split( ';' ).forEach( c => cuisines.add( c.trim() ) )
                    }
                } )
            } )

            const sortedCuisines = Array.from( cuisines ).sort()
            cuisineFilterButtons.innerHTML = '' // Clear previous buttons

            const createButton = ( text, cuisineValue ) => {
                const button = document.createElement( 'button' )
                button.textContent = text
                button.dataset.cuisine = cuisineValue
                button.className = 'px-3 py-1 border border-pink-300 rounded-full text-sm text-pink-700 hover:bg-pink-100 transition-colors duration-200'
                return button
            }

            const allButton = createButton( 'All Cuisines', '' )
            allButton.classList.add( 'selected' ) // 'All' is selected by default
            currentCuisineFilter = [ '' ]
            cuisineFilterButtons.appendChild( allButton )

            sortedCuisines.forEach( c => {
                const button = createButton( c.charAt( 0 ).toUpperCase() + c.slice( 1 ), c )
                cuisineFilterButtons.appendChild( button )
            } )

            if ( sortedCuisines.length > 0 ) {
                cuisineFilterButtons.parentElement.style.display = 'block'
            } else {
                cuisineFilterButtons.parentElement.style.display = 'none'
            }
        }

        function clearPreviousResults () {
            routeLayer.clearLayers()
            chargerLayer.clearLayers()
            restaurantLayer.clearLayers()
            stationData = []
            filteredChargerIDs = null
            currentSearchTerm = ''
            restaurantSearchInput.value = ''
            document.getElementById( 'chargers-tbody' ).innerHTML = ''
            // Stop location tracking when clearing results
            stopLocationTracking()
        }

        function showLoadingState ( message ) {
            document.getElementById( 'loading-container' ).classList.remove( 'hidden' )
            document.getElementById( 'loading-text' ).textContent = message
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
            searchForm.style.display = 'none'
            bottomResults.style.display = 'block'
            topToolbar.style.display = 'flex'
            mapElement.style.top = '60px'
            mapElement.style.height = 'calc(100vh - 60px)'
            bottomResults.style.top = '60px'
            bottomResults.style.height = 'calc(100vh - 60px)'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'
        }

        function showResultsTable () {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.remove( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
        }

        function showChargerInResults ( chargerId ) {
            // Show the results list view
            const bottomResults = document.getElementById( 'bottom-results' )
            bottomResults.style.display = 'block'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'

            // Find and scroll to the charger row
            const chargerRow = document.querySelector( `tr[data-charger-id="${ chargerId }"]` )
            if ( chargerRow ) {
                chargerRow.scrollIntoView( { behavior: 'smooth', block: 'center' } )
                // Highlight the row briefly
                chargerRow.style.backgroundColor = '#fef2f2'
                setTimeout( () => {
                    chargerRow.style.backgroundColor = ''
                }, 2000 )
            }

            // Invalidate map size after showing results
            setTimeout( () => map.invalidateSize(), 100 )
        }

        function showEmptyState ( message ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            const noResults = document.getElementById( 'no-results' )
            noResults.textContent = message
            noResults.classList.remove( 'hidden' )
        }

        function showErrorState ( message ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            updateStatus( message, true )
            // Optionally, revert to the search form
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
            topToolbar.style.display = 'none'
            mapElement.style.top = '0'
            mapElement.style.height = '100vh'
        }


        // --- API & GEOMETRY FUNCTIONS (largely unchanged) ---

        async function geocodeAddress ( address ) {
            const coordMatch = address.match( /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/ )
            if ( coordMatch ) {
                const lat = parseFloat( coordMatch[ 1 ] )
                const lon = parseFloat( coordMatch[ 2 ] )
                if ( lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180 ) return [ lon, lat ]
            }
            const url = `https://api.openrouteservice.org/geocode/search?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( address ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( `Geocoding failed: ${ response.statusText }` )
            const data = await response.json()
            if ( data.features && data.features.length > 0 ) return data.features[ 0 ].geometry.coordinates
            return null
        }

        async function getRoute ( startCoords, endCoords ) {
            const url = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson'
            const body = JSON.stringify( {
                "coordinates": [ startCoords, endCoords ],
                "radiuses": [ 5000, 5000 ]
            } )
            const response = await fetch( url, {
                method: 'POST',
                headers: {
                    'Authorization': ORS_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: body
            } )
            if ( !response.ok ) {
                const errorData = await response.json()
                throw new Error( errorData.error?.message || `Routing failed: ${ response.statusText }` )
            }
            const data = await response.json()
            return data.features[ 0 ]
        }

        async function getSuperchargers ( routeCoords ) {
            let minLat = Infinity,
                maxLat = -Infinity,
                minLon = Infinity,
                maxLon = -Infinity
            routeCoords.forEach( coord => {
                minLat = Math.min( minLat, coord[ 0 ] )
                maxLat = Math.max( maxLat, coord[ 0 ] )
                minLon = Math.min( minLon, coord[ 1 ] )
                maxLon = Math.max( maxLon, coord[ 1 ] )
            } )
            const padding = 0.5 // ~55km
            const query = `
                [out:json][timeout:30];
                (
                    node["amenity"="charging_station"]["operator"~"Tesla"](${ minLat - padding },${ minLon - padding },${ maxLat + padding },${ maxLon + padding });
                );
                out center;`
            const url = `https://overpass-api.de/api/interpreter?data=${ encodeURIComponent( query ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( "Failed to fetch Supercharger data." )
            const data = await response.json()
            return data.elements.map( el => ( {
                id: el.id,
                name: el.tags?.name || `Tesla Supercharger ${ el.id }`,
                address: {
                    street: el.tags?.[ 'addr:street' ] || '',
                    city: el.tags?.[ 'addr:city' ] || '',
                    state: el.tags?.[ 'addr:state' ] || ''
                },
                gps: {
                    latitude: el.lat || el.center?.lat,
                    longitude: el.lon || el.center?.lon
                },
                stallCount: parseInt( el.tags?.capacity ) || 'N/A'
            } ) )
        }

        function findChargersNearRoute ( allChargers, routeCoords, radiusMiles ) {
            return allChargers.filter( charger => {
                if ( !charger.gps ) return false
                const chargerPoint = { lat: charger.gps.latitude, lng: charger.gps.longitude }
                for ( let i = 0; i < routeCoords.length - 1; i++ ) {
                    const segmentStart = { lat: routeCoords[ i ][ 0 ], lng: routeCoords[ i ][ 1 ] }
                    const segmentEnd = { lat: routeCoords[ i + 1 ][ 0 ], lng: routeCoords[ i + 1 ][ 1 ] }
                    if ( pointToLineSegmentDistance( chargerPoint, segmentStart, segmentEnd ) <= radiusMiles ) {
                        return true
                    }
                }
                return false
            } )
        }

        async function getNearbyRestaurantsBulk ( locations, radius = 500 ) {
            if ( locations.length === 0 ) return []
            const results = locations.map( () => ( { restaurants: [] } ) )
            const queryParts = locations.map( loc => `node[amenity~"restaurant|fast_food|cafe|bar|pub|food_court|ice_cream|bakery"](around:${ radius },${ loc.latitude },${ loc.longitude });` )
            const query = `[out:json][timeout:30];(${ queryParts.join( '' ) });out;`
            try {
                const response = await fetch( 'https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: `data=${ encodeURIComponent( query ) }`
                } )
                if ( !response.ok ) throw new Error( "Failed to fetch restaurant data." )
                const data = await response.json()
                data.elements.forEach( element => {
                    let closestIndex = -1, closestDistance = Infinity
                    locations.forEach( ( loc, index ) => {
                        const d = getDistance( loc.latitude, loc.longitude, element.lat, element.lon )
                        if ( d < closestDistance ) {
                            closestDistance = d
                            closestIndex = index
                        }
                    } )
                    if ( closestIndex !== -1 && closestDistance <= radius ) {
                        results[ closestIndex ].restaurants.push( {
                            id: element.id,
                            name: element.tags?.name || `Restaurant ${ element.id }`,
                            cuisine: element.tags?.cuisine || 'N/A',
                            opening_hours: element.tags?.opening_hours || 'N/A',
                            gps: { latitude: element.lat, longitude: element.lon },
                            distance: closestDistance
                        } )
                    }
                } )
                results.forEach( r => r.restaurants.sort( ( a, b ) => a.distance - b.distance ) )
                return results
            } catch ( error ) {
                console.warn( "Could not fetch restaurant data:", error )
                return results // Return empty restaurant arrays on failure
            }
        }

        function distance ( lat1, lon1, lat2, lon2 ) {
            const R = 3958.8 // Miles
            const dLat = ( lat2 - lat1 ) * Math.PI / 180
            const dLon = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( dLat / 2 ) * Math.sin( dLat / 2 ) + Math.cos( lat1 * Math.PI / 180 ) * Math.cos( lat2 * Math.PI / 180 ) * Math.sin( dLon / 2 ) * Math.sin( dLon / 2 )
            return R * ( 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) ) )
        }

        function getDistance ( lat1, lon1, lat2, lon2 ) {
            const R = 6371e3 // Metres
            const œÜ1 = lat1 * Math.PI / 180
            const œÜ2 = lat2 * Math.PI / 180
            const ŒîœÜ = ( lat2 - lat1 ) * Math.PI / 180
            const ŒîŒª = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( ŒîœÜ / 2 ) * Math.sin( ŒîœÜ / 2 ) + Math.cos( œÜ1 ) * Math.cos( œÜ2 ) * Math.sin( ŒîŒª / 2 ) * Math.sin( ŒîŒª / 2 )
            return Math.round( R * ( 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) ) ) )
        }

        function pointToLineSegmentDistance ( p, a, b ) {
            const l2 = ( a.lat - b.lat ) ** 2 + ( a.lng - b.lng ) ** 2
            if ( l2 === 0 ) return distance( p.lat, p.lng, a.lat, a.lng )
            let t = ( ( p.lat - a.lat ) * ( b.lat - a.lat ) + ( p.lng - a.lng ) * ( b.lng - a.lng ) ) / l2
            t = Math.max( 0, Math.min( 1, t ) )
            const projection = {
                lat: a.lat + t * ( b.lat - a.lat ),
                lng: a.lng + t * ( b.lng - a.lng )
            }
            return distance( p.lat, p.lng, projection.lat, projection.lng )
        }

        // --- UNCHANGED HELPER FUNCTIONS (Autocomplete, Location, Modals, etc.) ---

        async function handleLocationClick () {
            // If already tracking, stop it
            if ( locationTrackingInterval ) {
                stopLocationTracking()
                updateStatus( "Location tracking stopped.", false )
                return
            }

            locationText.textContent = 'Getting location...'
            loadingSpinner.classList.remove( 'hidden' )
            locationBtn.disabled = true
            try {
                const position = await new Promise( ( resolve, reject ) => navigator.geolocation.getCurrentPosition( resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 10000
                } ) )
                const { latitude: lat, longitude: lon } = position.coords
                const address = await reverseGeocode( lat, lon )
                originInput.value = address || `${ lat.toFixed( 4 ) }, ${ lon.toFixed( 4 ) }`
                updateStatus( "Location detected and set as origin.", false )
                // Start continuous location tracking
                startLocationTracking()
                // Update button to show tracking is active
                locationText.textContent = 'üë∏ Tracking Active'
                locationBtn.classList.add( 'tracking-active' )
            } catch ( error ) {
                console.log( "Geolocation error:", error )
                updateStatus( "Could not access your location.", true )
            } finally {
                loadingSpinner.classList.add( 'hidden' )
                locationBtn.disabled = false
            }
        }

        function startLocationTracking () {
            // Clear any existing tracking
            if ( locationTrackingInterval ) {
                clearInterval( locationTrackingInterval )
            }

            // Show GPS button
            document.getElementById( 'gps-btn' ).classList.remove( 'hidden' )

            // Get initial position immediately
            navigator.geolocation.getCurrentPosition(
                ( position ) => {
                    const { latitude: lat, longitude: lon } = position.coords
                    updateUserLocationMarker( lat, lon )
                },
                ( error ) => {
                    console.log( "Initial location error:", error )
                },
                {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 10000
                }
            )

            // Start tracking every 5 seconds
            locationTrackingInterval = setInterval( async () => {
                try {
                    const position = await new Promise( ( resolve, reject ) =>
                        navigator.geolocation.getCurrentPosition( resolve, reject, {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 10000 // Accept positions up to 10 seconds old
                        } )
                    )
                    const { latitude: lat, longitude: lon } = position.coords
                    updateUserLocationMarker( lat, lon )
                } catch ( error ) {
                    console.log( "Location tracking error:", error )
                    // Don't show error for tracking failures, just continue
                }
            }, 5000 )
        }

        function updateUserLocationMarker ( lat, lon ) {
            // Remove existing marker if it exists
            if ( userLocationMarker ) {
                userLocationLayer.removeLayer( userLocationMarker )
            }

            // Create new marker with princess icon and lat/lon popup
            userLocationMarker = L.marker( [ lat, lon ], {
                icon: L.divIcon( {
                    className: 'princess-marker',
                    html: 'üë∏',
                    iconSize: [ 36, 36 ],
                } )
            } ).bindPopup( `<strong>Princess Location</strong><br>Lat: ${ lat.toFixed( 6 ) }<br>Lon: ${ lon.toFixed( 6 ) }` )

            // Add to map
            userLocationLayer.addLayer( userLocationMarker )
        }

        function stopLocationTracking () {
            if ( locationTrackingInterval ) {
                clearInterval( locationTrackingInterval )
                locationTrackingInterval = null
            }
            if ( userLocationMarker ) {
                userLocationLayer.removeLayer( userLocationMarker )
                userLocationMarker = null
            }
            // Hide GPS button
            document.getElementById( 'gps-btn' ).classList.add( 'hidden' )
            // Reset button appearance
            locationText.textContent = 'üë∏ Use Current Location'
            locationBtn.classList.remove( 'tracking-active' )
        }

        async function reverseGeocode ( lat, lon ) {
            const url = `https://api.openrouteservice.org/geocode/reverse?api_key=${ ORS_API_KEY }&point.lon=${ lon }&point.lat=${ lat }&size=1`
            const response = await fetch( url )
            if ( !response.ok ) return null
            const data = await response.json()
            return data.features?.[ 0 ]?.properties?.label || null
        }

        let debounceTimer
        function setupAutocomplete ( inputElement, suggestionsDiv ) {
            inputElement.addEventListener( 'input', () => {
                clearTimeout( debounceTimer )
                debounceTimer = setTimeout( async () => {
                    const query = inputElement.value
                    if ( query.length < 3 ) {
                        suggestionsDiv.classList.add( 'hidden' )
                        return
                    }
                    try {
                        const url = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( query ) }&size=5`
                        const response = await fetch( url )
                        if ( !response.ok ) throw new Error( 'Autocomplete failed' )
                        const data = await response.json()
                        displaySuggestions( data.features, suggestionsDiv, inputElement )
                    } catch ( error ) {
                        console.error( 'Autocomplete error:', error )
                        suggestionsDiv.classList.add( 'hidden' )
                    }
                }, 300 )
            } )
            inputElement.addEventListener( 'blur', () => setTimeout( () => suggestionsDiv.classList.add( 'hidden' ), 150 ) )
        }

        function displaySuggestions ( features, suggestionsDiv, input ) {
            suggestionsDiv.innerHTML = ''
            if ( !features || features.length === 0 ) {
                suggestionsDiv.classList.add( 'hidden' )
                return
            }
            features.forEach( feature => {
                const suggestion = document.createElement( 'div' )
                suggestion.className = 'autocomplete-suggestion'
                suggestion.textContent = feature.properties.label
                suggestion.addEventListener( 'click', () => {
                    input.value = feature.properties.label
                    suggestionsDiv.classList.add( 'hidden' )
                } )
                suggestionsDiv.appendChild( suggestion )
            } )
            const inputRect = input.getBoundingClientRect()
            suggestionsDiv.style.left = `${ inputRect.left }px`
            suggestionsDiv.style.top = `${ inputRect.bottom + window.scrollY }px`
            suggestionsDiv.style.width = `${ inputRect.width }px`
            suggestionsDiv.classList.remove( 'hidden' )
        }

        setupAutocomplete( originInput, originSuggestions )
        setupAutocomplete( destinationInput, destinationSuggestions )

        document.getElementById( 'toggle-btn' ).addEventListener( 'click', () => {
            const isHidden = bottomResults.style.display === 'none'
            bottomResults.style.display = isHidden ? 'block' : 'none'
            document.getElementById( 'toggle-btn' ).textContent = isHidden ? 'Show map' : 'Show Results'
            setTimeout( () => map.invalidateSize(), 100 )
        } )

        newSearchBtn.addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.remove( 'hidden' ) )
        document.getElementById( 'cancel-new-search' ).addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.add( 'hidden' ) )
        document.getElementById( 'confirm-new-search' ).addEventListener( 'click', () => {
            stopLocationTracking()
            window.location.href = window.location.pathname
        } )

        // Toggle cuisine filter buttons
        document.getElementById( 'toggle-cuisine-btn' ).addEventListener( 'click', () => {
            const cuisineDiv = document.getElementById( 'cuisine-filter-buttons' )
            const isVisible = cuisineDiv.style.display !== 'none'
            cuisineDiv.style.display = isVisible ? 'none' : 'flex'
        } )

        // GPS button to center on user location
        document.getElementById( 'gps-btn' ).addEventListener( 'click', () => {
            if ( userLocationMarker ) {
                const latLng = userLocationMarker.getLatLng()
                map.setView( latLng, Math.max( map.getZoom(), 15 ) )
                // Hide results panel
                bottomResults.style.display = 'none'
                document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                setTimeout( () => map.invalidateSize(), 100 )
            }
        } )

        function updateStatus ( message, isError = false ) {
            statusMessage.textContent = message
            statusMessage.className = `text-center mt-3 text-sm font-medium ${ isError ? 'text-red-600' : 'text-pink-600' }`
        }

        function updateUrlForSearch ( origin, destination ) {
            const url = new URL( window.location )
            url.searchParams.set( 'origin', encodeURIComponent( origin ) )
            url.searchParams.set( 'destination', encodeURIComponent( destination ) )
            window.history.pushState( {}, '', url )
        }

        // --- AUTO-START LOCATION TRACKING ---
        async function autoStartLocationTracking () {
            // Check if geolocation is supported
            if ( !navigator.geolocation ) {
                console.log( "Geolocation not supported" )
                return
            }

            try {
                // Try to get current position without prompting (if permission already granted)
                const position = await new Promise( ( resolve, reject ) =>
                    navigator.geolocation.getCurrentPosition( resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 30000 // Accept positions up to 30 seconds old
                    } )
                )

                const { latitude: lat, longitude: lon } = position.coords
                console.log( "Auto-started location tracking with coordinates:", lat, lon )

                // Start continuous tracking (this will also update the marker immediately)
                startLocationTracking()

                // Update button to show tracking is active
                locationText.textContent = 'üë∏ Tracking Active'
                locationBtn.classList.add( 'tracking-active' )

                // Set origin input with coordinates (don't reverse geocode to keep it fast)
                originInput.value = `${ lat.toFixed( 6 ) }, ${ lon.toFixed( 6 ) }`

            } catch ( error ) {
                console.log( "Auto location detection failed:", error.message )
                // Don't show error - user can manually click the button if they want
            }
        }

        // Start auto location tracking when page loads
        window.addEventListener( 'load', () => {
            setTimeout( autoStartLocationTracking, 1000 ) // Small delay to ensure everything is loaded
        } )

    </script>

</body>

</html>