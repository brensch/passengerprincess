<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesla Supercharger Route Planner</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- LeafletJS for the map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        /* Full screen map */
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        /* Overlay form at bottom */
        .overlay-form {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            max-height: 50vh;
            overflow-y: auto;
        }

        /* Bottom results area */
        .bottom-results {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            max-height: 50vh;
            overflow-y: auto;
            display: none;
        }

        /* Custom scrollbar for the results list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .overlay-form {
                padding: 10px;
                max-height: 40vh;
            }

            .bottom-results {
                padding: 10px;
                max-height: 60vh;
            }

            .autocomplete-suggestions {
                max-height: 150px;
            }
        }

        .autocomplete-suggestion {
            padding: 8px;
            cursor: pointer;
        }

        .autocomplete-suggestion:hover {
            background: #f0f0f0;
        }
    </style>
</head>

<body class="bg-gray-100 font-sans antialiased">
    <div id="map"></div>

    <!-- Bottom Results Area -->
    <div class="bottom-results" id="bottom-results">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold text-gray-800">Superchargers & Restaurants</h2>
            <button id="new-search-btn" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg text-sm">
                New Search
            </button>
        </div>
        <div id="results-list">
            <p class="text-gray-500">Search for a route to see results.</p>
        </div>
    </div> <!-- Overlay Input Form -->
    <div class="overlay-form" id="search-form">
        <header class="text-center mb-4">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">Tesla Supercharger Route Planner</h1>
            <p class="text-gray-600 text-sm">Find your route and nearby amenities.</p>
        </header>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-end">
            <div class="relative">
                <label for="origin" class="block text-sm font-medium text-gray-700">Origin</label>
                <input type="text" id="origin"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
                    placeholder="e.g., San Francisco, CA">
                <div id="origin-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="relative">
                <label for="destination" class="block text-sm font-medium text-gray-700">Destination</label>
                <input type="text" id="destination"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
                    placeholder="e.g., Los Angeles, CA">
                <div id="destination-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="md:col-span-2">
                <button id="find-route-btn"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out text-sm">
                    Find Route & Amenities
                </button>
            </div>
        </div>
        <div id="status-message" class="text-center mt-3 text-gray-600 font-medium text-sm"></div>
    </div>

    <!-- Bottom Results Area -->
    <div class="bottom-results" id="bottom-results">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold text-gray-800">Superchargers & Restaurants</h2>
            <button id="new-search-btn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">
                New Search
            </button>
        </div>
        <div id="results-list">
            <p class="text-gray-500">Search for a route to see results.</p>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        // IMPORTANT: Get your free API key from https://openrouteservice.org/
        const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImVjNDQ2NWRmYWFiODQ3ZmVhMTM2NTNhODA0YjRiYWI4IiwiaCI6Im11cm11cjY0In0='
        // Distance in miles to search for chargers from the route
        const SEARCH_RADIUS_MILES = 5

        // --- DOM ELEMENTS ---
        const originInput = document.getElementById( 'origin' )
        const destinationInput = document.getElementById( 'destination' )
        const findRouteBtn = document.getElementById( 'find-route-btn' )
        const statusMessage = document.getElementById( 'status-message' )
        const mapElement = document.getElementById( 'map' )
        const originSuggestions = document.getElementById( 'origin-suggestions' )
        const destinationSuggestions = document.getElementById( 'destination-suggestions' )
        const searchForm = document.getElementById( 'search-form' )
        const bottomResults = document.getElementById( 'bottom-results' )
        const resultsList = document.getElementById( 'results-list' )
        const newSearchBtn = document.getElementById( 'new-search-btn' )

        // --- MAP INITIALIZATION ---
        let map = L.map( mapElement ).setView( [ 37.7749, -122.4194 ], 6 ) // Default to SF
        L.tileLayer( 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        } ).addTo( map )

        let routeLayer = L.layerGroup().addTo( map )
        let chargerLayer = L.layerGroup().addTo( map )

        // --- EVENT LISTENERS ---
        findRouteBtn.addEventListener( 'click', handleRouteSearch )
        newSearchBtn.addEventListener( 'click', () => {
            clearMap()
            originInput.value = ''
            destinationInput.value = ''
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
            updateStatus( '' )
        } )

        // Autocomplete for origin
        let originDebounceTimer
        originInput.addEventListener( 'input', () => {
            clearTimeout( originDebounceTimer )
            originDebounceTimer = setTimeout( () => fetchSuggestions( originInput.value, originSuggestions, originInput ), 300 )
        } )
        originInput.addEventListener( 'focus', () => {
            if ( originInput.value ) fetchSuggestions( originInput.value, originSuggestions, originInput )
        } )
        originInput.addEventListener( 'blur', () => setTimeout( () => originSuggestions.classList.add( 'hidden' ), 150 ) )

        // Autocomplete for destination
        let destinationDebounceTimer
        destinationInput.addEventListener( 'input', () => {
            clearTimeout( destinationDebounceTimer )
            destinationDebounceTimer = setTimeout( () => fetchSuggestions( destinationInput.value, destinationSuggestions, destinationInput ), 300 )
        } )
        destinationInput.addEventListener( 'focus', () => {
            if ( destinationInput.value ) fetchSuggestions( destinationInput.value, destinationSuggestions, destinationInput )
        } )
        destinationInput.addEventListener( 'blur', () => setTimeout( () => destinationSuggestions.classList.add( 'hidden' ), 150 ) )

        // --- CORE FUNCTIONS ---

        /**
         * Main function to handle the route search process.
         */
        async function handleRouteSearch () {
            const origin = originInput.value.trim()
            const destination = destinationInput.value.trim()

            if ( !origin || !destination ) {
                updateStatus( "Please enter both an origin and a destination.", true )
                return
            }
            if ( ORS_API_KEY === 'YOUR_API_KEY_HERE' ) {
                updateStatus( "Please add your OpenRouteService API key to the script.", true )
                alert( "API Key missing. Please edit the HTML file and add your free API key from openrouteservice.org." )
                return
            }

            // Clear previous results
            clearMap()
            updateStatus( "Finding route..." )
            resultsList.innerHTML = '<p class="text-gray-500">Searching...</p>'

            // Hide search form and show results
            searchForm.style.display = 'none'
            bottomResults.style.display = 'block'

            try {
                // Step 1: Geocode addresses to get coordinates
                const [ originCoords, destCoords ] = await Promise.all( [
                    geocodeAddress( origin ),
                    geocodeAddress( destination )
                ] )

                if ( !originCoords || !destCoords ) {
                    updateStatus( "Could not find one or both locations. Please be more specific.", true )
                    return
                }

                // Step 2: Fetch the route geometry
                updateStatus( "Calculating route..." )
                const routeData = await getRoute( originCoords, destCoords )
                const routeCoords = routeData.geometry.coordinates.map( c => [ c[ 1 ], c[ 0 ] ] ) // Flip coords for Leaflet
                drawRoute( routeCoords )
                map.fitBounds( L.polyline( routeCoords ).getBounds().pad( 0.1 ) )

                // Step 3: Fetch all Superchargers
                updateStatus( "Finding Superchargers..." )
                const allChargers = await getSuperchargers( routeCoords )

                // Step 4: Find chargers along the route
                const chargersOnRoute = findChargersNearRoute( allChargers, routeCoords, SEARCH_RADIUS_MILES )

                // Step 5: Display the results
                displaySuperchargersAndRestaurants( chargersOnRoute )
                updateStatus( `Found ${ chargersOnRoute.length } Superchargers with restaurants.`, false )


            } catch ( error ) {
                console.error( "Error during route search:", error )
                if ( error.message && error.message.includes( "routable point" ) ) {
                    updateStatus( "Could not find a routable location near one of the addresses. Please try a different or more specific location.", true )
                } else {
                    updateStatus( "An error occurred. Please check the console for details.", true )
                }
            }
        }

        /**
         * Converts an address string to latitude/longitude coordinates.
         * @param {string} address The address to geocode.
         * @returns {Promise<[number, number]|null>} A promise resolving to [lon, lat] or null.
         */
        async function geocodeAddress ( address ) {
            const url = `https://api.openrouteservice.org/geocode/search?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( address ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( `Geocoding failed: ${ response.statusText }` )
            const data = await response.json()
            if ( data.features && data.features.length > 0 ) {
                return data.features[ 0 ].geometry.coordinates // [lon, lat]
            }
            return null
        }

        /**
         * Fetches autocomplete suggestions for an address.
         * @param {string} query The partial address query.
         * @param {HTMLElement} suggestionsDiv The div to display suggestions.
         * @param {HTMLElement} input The input element.
         */
        async function fetchSuggestions ( query, suggestionsDiv, input ) {
            if ( query.length < 3 ) {
                suggestionsDiv.classList.add( 'hidden' )
                return
            }
            try {
                const url = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( query ) }&size=5`
                const response = await fetch( url )
                if ( !response.ok ) throw new Error( `Autocomplete failed: ${ response.statusText }` )
                const data = await response.json()
                displaySuggestions( data.features, suggestionsDiv, input )
            } catch ( error ) {
                console.error( 'Autocomplete error:', error )
                suggestionsDiv.classList.add( 'hidden' )
            }
        }

        /**
         * Displays the suggestions in the dropdown.
         * @param {Array} features The geocoding features.
         * @param {HTMLElement} suggestionsDiv The div to display suggestions.
         * @param {HTMLElement} input The input element.
         */
        function displaySuggestions ( features, suggestionsDiv, input ) {
            suggestionsDiv.innerHTML = ''
            if ( features && features.length > 0 ) {
                features.forEach( feature => {
                    const suggestion = document.createElement( 'div' )
                    suggestion.className = 'autocomplete-suggestion'
                    suggestion.textContent = feature.properties.label
                    suggestion.addEventListener( 'click', () => {
                        input.value = feature.properties.label
                        suggestionsDiv.classList.add( 'hidden' )
                    } )
                    suggestionsDiv.appendChild( suggestion )
                } )
                suggestionsDiv.classList.remove( 'hidden' )
            } else {
                suggestionsDiv.classList.add( 'hidden' )
            }
        }

        /**
         * Fetches a route between two coordinates from OpenRouteService.
         * @param {[number, number]} startCoords [lon, lat] for the start point.
         * @param {[number, number]} endCoords [lon, lat] for the end point.
         * @returns {Promise<object>} A promise resolving to the route data.
         */
        async function getRoute ( startCoords, endCoords ) {
            const url = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson'
            const body = JSON.stringify( {
                "coordinates": [ startCoords, endCoords ],
                "radiuses": [ 5000, 5000 ]  // Allow snapping within 5km
            } )
            const response = await fetch( url, {
                method: 'POST',
                headers: {
                    'Authorization': ORS_API_KEY,
                    'Content-Type': 'application/json; charset=utf-8',
                    'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',
                },
                body: body
            } )
            if ( !response.ok ) throw new Error( `Routing failed: ${ response.statusText }` )
            const data = await response.json()
            return data.features[ 0 ]
        }

        /**
         * Fetches restaurants near a given location using Overpass API.
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} radius Radius in meters
         * @returns {Promise<Array<object>>} Array of restaurant objects
         */
        async function getNearbyRestaurants ( lat, lon, radius = 1000 ) {
            const query = `
                [out:json][timeout:15];
                (
                    node["amenity"="restaurant"](around:${ radius },${ lat },${ lon });
                );
                out meta;
            `
            const url = `https://overpass-api.de/api/interpreter?data=${ encodeURIComponent( query ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( "Failed to fetch restaurant data." )
            const data = await response.json()

            return data.elements.slice( 0, 5 ).map( element => ( {
                id: element.id,
                name: element.tags?.name || `Restaurant ${ element.id }`,
                cuisine: element.tags?.cuisine || 'Unknown',
                address: {
                    street: element.tags?.[ 'addr:street' ] || '',
                    city: element.tags?.[ 'addr:city' ] || '',
                    state: element.tags?.[ 'addr:state' ] || ''
                },
                gps: {
                    latitude: element.lat,
                    longitude: element.lon
                }
            } ) )
        }
        async function getSuperchargers ( routeCoords = null ) {
            // Using Overpass API to query OpenStreetMap for Tesla Superchargers
            let query

            if ( routeCoords && routeCoords.length > 0 ) {
                // Calculate bounding box of the route
                let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity
                routeCoords.forEach( coord => {
                    minLat = Math.min( minLat, coord[ 0 ] )
                    maxLat = Math.max( maxLat, coord[ 0 ] )
                    minLon = Math.min( minLon, coord[ 1 ] )
                    maxLon = Math.max( maxLon, coord[ 1 ] )
                } )

                // Add padding (about 50km)
                const latPadding = 0.45 // ~50km
                const lonPadding = 0.45 // ~50km
                minLat -= latPadding
                maxLat += latPadding
                minLon -= lonPadding
                maxLon += lonPadding

                query = `
                    [out:json][timeout:30];
                    (
                        node["amenity"="charging_station"]["operator"~"Tesla"](${ minLat },${ minLon },${ maxLat },${ maxLon });
                        way["amenity"="charging_station"]["operator"~"Tesla"](${ minLat },${ minLon },${ maxLat },${ maxLon });
                        relation["amenity"="charging_station"]["operator"~"Tesla"](${ minLat },${ minLon },${ maxLat },${ maxLon });
                    );
                    out center meta;
                `
            } else {
                // Fallback: search in a smaller area (California)
                query = `
                    [out:json][timeout:30];
                    area["ISO3166-1"="US-CA"]->.ca;
                    (
                        node["amenity"="charging_station"]["operator"~"Tesla"](area.ca);
                        way["amenity"="charging_station"]["operator"~"Tesla"](area.ca);
                        relation["amenity"="charging_station"]["operator"~"Tesla"](area.ca);
                    );
                    out center meta;
                `
            }

            const url = `https://overpass-api.de/api/interpreter?data=${ encodeURIComponent( query ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( "Failed to fetch Supercharger data from OpenStreetMap." )
            const data = await response.json()

            // Transform OSM data to match expected format
            return data.elements.map( element => ( {
                id: element.id,
                name: element.tags?.name || `Tesla Supercharger ${ element.id }`,
                address: {
                    street: element.tags?.[ 'addr:street' ] || '',
                    city: element.tags?.[ 'addr:city' ] || '',
                    state: element.tags?.[ 'addr:state' ] || '',
                    zip: element.tags?.[ 'addr:postcode' ] || ''
                },
                gps: {
                    latitude: element.lat || element.center?.lat,
                    longitude: element.lon || element.center?.lon
                },
                status: element.tags?.opening_hours ? 'open' : 'unknown',
                stallCount: parseInt( element.tags?.capacity ) || 0
            } ) )
        }

        /**
         * Displays Superchargers and their nearby restaurants in the results list.
         * @param {Array<object>} chargers - The chargers to display.
         */
        async function displaySuperchargersAndRestaurants ( chargers ) {
            if ( chargers.length === 0 ) {
                resultsList.innerHTML = '<p class="text-gray-500">No Superchargers found within the search radius of your route.</p>'
                return
            }

            resultsList.innerHTML = '' // Clear list
            for ( const charger of chargers ) {
                // Add marker to map
                const chargerLatLng = [ charger.gps.latitude, charger.gps.longitude ]
                const marker = L.marker( chargerLatLng, {
                    icon: L.divIcon( {
                        className: 'custom-div-icon',
                        html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="#cc0000" class="w-6 h-8"><path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67a24 24 0 0 1-35.464 0zM192 256a64 64 0 1 0 0-128 64 64 0 1 0 0 128z"/></svg>`,
                        iconSize: [ 24, 32 ],
                        iconAnchor: [ 12, 32 ]
                    } )
                } ).addTo( chargerLayer )

                // Fetch restaurants for this charger
                let restaurants = []
                try {
                    restaurants = await getNearbyRestaurants( charger.gps.latitude, charger.gps.longitude, 2000 ) // 2km
                    restaurants = restaurants.slice( 0, 3 ) // Limit to 3 restaurants per charger
                } catch ( error ) {
                    console.error( 'Error fetching restaurants for charger:', charger.name, error )
                }

                // Create popup content with restaurants
                let popupContent = `
                    <div class="font-sans max-w-xs">
                        <strong class="text-lg">${ charger.name }</strong><br>
                        <strong>Status:</strong> ${ charger.status }<br>
                        <strong>Stalls:</strong> ${ charger.stallCount }<br>
                        <a href="https://www.google.com/maps/search/?api=1&query=${ charger.gps.latitude },${ charger.gps.longitude }" target="_blank" class="text-blue-500 hover:underline text-sm">Open in Google Maps</a>
                `

                if ( restaurants.length > 0 ) {
                    popupContent += '<br><br><strong>Nearby Restaurants:</strong><br>'
                    restaurants.forEach( restaurant => {
                        popupContent += `<div class="text-sm mt-1">• ${ restaurant.name } (${ restaurant.cuisine })</div>`
                    } )
                }

                popupContent += '</div>'
                marker.bindPopup( popupContent )

                // Add entry to list
                const listItem = document.createElement( 'div' )
                listItem.className = 'p-4 border-b hover:bg-gray-50 cursor-pointer rounded-lg'
                listItem.innerHTML = `
                    <h3 class="font-bold text-gray-800">${ charger.name }</h3>
                    <p class="text-sm text-gray-600">${ charger.address.street }, ${ charger.address.city }</p>
                    <p class="text-sm text-gray-500">Stalls: ${ charger.stallCount } | Status: ${ charger.status }</p>
                `
                if ( restaurants.length > 0 ) {
                    listItem.innerHTML += '<br><strong class="text-sm">Nearby Restaurants:</strong><br>'
                    restaurants.forEach( restaurant => {
                        listItem.innerHTML += `<div class="text-sm mt-1">• ${ restaurant.name } (${ restaurant.cuisine })</div>`
                    } )
                }
                listItem.addEventListener( 'click', () => {
                    map.setView( chargerLatLng, 15 )
                    marker.openPopup()
                } )
                resultsList.appendChild( listItem )
            }
        }

        /**
         * Filters a list of all chargers to find those within a certain radius of the route.
         * @param {Array<object>} allChargers - Array of all supercharger sites.
         * @param {Array<[number, number]>} routeCoords - Array of [lat, lon] points for the route.
         * @param {number} radiusMiles - The search radius in miles.
         * @returns {Array<object>} An array of filtered charger objects.
         */
        function findChargersNearRoute ( allChargers, routeCoords, radiusMiles ) {
            const chargersOnRoute = []
            for ( const charger of allChargers ) {
                if ( charger.gps ) {
                    const chargerPoint = { lat: charger.gps.latitude, lng: charger.gps.longitude }

                    // Check distance to route segments
                    for ( let i = 0; i < routeCoords.length - 1; i++ ) {
                        const segmentStart = { lat: routeCoords[ i ][ 0 ], lng: routeCoords[ i ][ 1 ] }
                        const segmentEnd = { lat: routeCoords[ i + 1 ][ 0 ], lng: routeCoords[ i + 1 ][ 1 ] }
                        const segmentDistance = pointToLineSegmentDistance( chargerPoint, segmentStart, segmentEnd )

                        if ( segmentDistance <= radiusMiles ) {
                            chargersOnRoute.push( charger )
                            break
                        }
                    }

                    // Also check distance to individual route points (every 10th point to optimize)
                    if ( chargersOnRoute.indexOf( charger ) === -1 ) {
                        for ( let i = 0; i < routeCoords.length; i += 10 ) {
                            const routePoint = { lat: routeCoords[ i ][ 0 ], lng: routeCoords[ i ][ 1 ] }
                            const pointDistance = distance( chargerPoint.lat, chargerPoint.lng, routePoint.lat, routePoint.lng )

                            if ( pointDistance <= radiusMiles ) {
                                chargersOnRoute.push( charger )
                                break
                            }
                        }
                    }
                }
            }
            return chargersOnRoute
        }

        /**
         * Displays Superchargers and their nearby restaurants.
         * @param {Array<object>} chargers - The chargers to display.
         */
        async function displaySuperchargersAndRestaurants ( chargers ) {
            if ( chargers.length === 0 ) {
                resultsList.innerHTML = '<p class="text-gray-500">No Superchargers found within 1km of your route.</p>'
                return
            }

            resultsList.innerHTML = '' // Clear list
            for ( const charger of chargers ) {
                // Add marker to map
                const chargerLatLng = [ charger.gps.latitude, charger.gps.longitude ]
                const marker = L.marker( chargerLatLng, {
                    icon: L.divIcon( {
                        className: 'custom-div-icon',
                        html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="#cc0000" class="w-6 h-8"><path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67a24 24 0 0 1-35.464 0zM192 256a64 64 0 1 0 0-128 64 64 0 1 0 0 128z"/></svg>`,
                        iconSize: [ 24, 32 ],
                        iconAnchor: [ 12, 32 ]
                    } )
                } ).addTo( chargerLayer )

                // Fetch restaurants for this charger
                let restaurants = []
                try {
                    restaurants = await getNearbyRestaurants( charger.gps.latitude, charger.gps.longitude, 1000 )
                } catch ( error ) {
                    console.error( 'Error fetching restaurants for charger:', charger.name, error )
                }

                // Create popup content with restaurants
                let popupContent = `
                    <div class="font-sans max-w-xs">
                        <strong class="text-lg">${ charger.name }</strong><br>
                        <strong>Status:</strong> ${ charger.status }<br>
                        <strong>Stalls:</strong> ${ charger.stallCount }<br>
                        <a href="https://www.google.com/maps/search/?api=1&query=${ charger.gps.latitude },${ charger.gps.longitude }" target="_blank" class="text-blue-500 hover:underline text-sm">Open in Google Maps</a>
                `

                if ( restaurants.length > 0 ) {
                    popupContent += '<br><br><strong>Nearby Restaurants:</strong><br>'
                    restaurants.slice( 0, 5 ).forEach( restaurant => {
                        popupContent += `<div class="text-sm mt-1">• ${ restaurant.name } (${ restaurant.cuisine || 'Restaurant' })</div>`
                    } )
                }

                popupContent += '</div>'
                marker.bindPopup( popupContent )

                // Add entry to list
                const chargerDiv = document.createElement( 'div' )
                chargerDiv.className = 'mb-6 p-4 bg-white rounded-lg shadow-sm border'

                chargerDiv.innerHTML = `
                    <h3 class="font-bold text-gray-800 text-lg mb-2">${ charger.name }</h3>
                    <p class="text-sm text-gray-600 mb-2">${ charger.address.street || '' } ${ charger.address.city || '' }</p>
                    <p class="text-sm text-gray-500 mb-3">Stalls: ${ charger.stallCount } | Status: ${ charger.status }</p>
                `

                if ( restaurants.length > 0 ) {
                    chargerDiv.innerHTML += '<h4 class="font-semibold text-gray-700 mb-2">Nearby Restaurants:</h4>'
                    const restaurantList = document.createElement( 'ul' )
                    restaurantList.className = 'space-y-1'

                    restaurants.slice( 0, 5 ).forEach( restaurant => {
                        const li = document.createElement( 'li' )
                        li.className = 'text-sm text-gray-600'
                        li.innerHTML = `<strong>${ restaurant.name }</strong> - ${ restaurant.cuisine || 'Restaurant' }`
                        restaurantList.appendChild( li )
                    } )

                    chargerDiv.appendChild( restaurantList )
                }

                chargerDiv.addEventListener( 'click', () => {
                    map.setView( chargerLatLng, 15 )
                    marker.openPopup()
                } )

                resultsList.appendChild( chargerDiv )
            }
        }



        // --- MAP UTILITY FUNCTIONS ---

        function drawRoute ( coords ) {
            L.polyline( coords, { color: 'blue', weight: 5, opacity: 0.7 } ).addTo( routeLayer )
        }

        function clearMap () {
            routeLayer.clearLayers()
            chargerLayer.clearLayers()
            // Show search form and hide results
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
        }

        function updateStatus ( message, isError = false ) {
            statusMessage.textContent = message
            statusMessage.className = isError
                ? 'text-center mt-4 text-red-600 font-medium'
                : 'text-center mt-4 text-gray-600 font-medium'
        }

        // --- GEOMETRY HELPER FUNCTIONS ---

        /**
         * Calculates the shortest distance from a point to a line segment in miles.
         * @param {{lat: number, lng: number}} p - The point.
         * @param {{lat: number, lng: number}} a - Start point of the line segment.
         * @param {{lat: number, lng: number}} b - End point of the line segment.
         * @returns {number} The distance in miles.
         */
        function pointToLineSegmentDistance ( p, a, b ) {
            const l2 = latLngDistSqr( a, b )
            if ( l2 == 0 ) return distance( p.lat, p.lng, a.lat, a.lng )

            let t = ( ( p.lat - a.lat ) * ( b.lat - a.lat ) + ( p.lng - a.lng ) * ( b.lng - a.lng ) ) / l2
            t = Math.max( 0, Math.min( 1, t ) )

            const projection = {
                lat: a.lat + t * ( b.lat - a.lat ),
                lng: a.lng + t * ( b.lng - a.lng )
            }

            return distance( p.lat, p.lng, projection.lat, projection.lng )
        }

        function latLngDistSqr ( p1, p2 ) {
            const dx = p1.lat - p2.lat
            const dy = p1.lng - p2.lng
            return dx * dx + dy * dy
        }

        /**
         * Calculates distance between two lat/lon points using Haversine formula.
         * @returns {number} Distance in miles.
         */
        function distance ( lat1, lon1, lat2, lon2 ) {
            const R = 3958.8 // Radius of the Earth in miles
            const dLat = ( lat2 - lat1 ) * Math.PI / 180
            const dLon = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( dLat / 2 ) * Math.sin( dLat / 2 ) +
                Math.cos( lat1 * Math.PI / 180 ) * Math.cos( lat2 * Math.PI / 180 ) *
                Math.sin( dLon / 2 ) * Math.sin( dLon / 2 )
            const c = 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) )
            return R * c
        }

    </script>

</body>

</html>