<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passenger Princess Protector</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- LeafletJS for the map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        /* Full screen map */
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: calc(100vh - 41px);
            width: 100vw;
            position: absolute;
            top: 41px;
            margin: 0;
            padding: 0;
        }

        /* Overlay form at bottom */
        .overlay-form {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-height: 50vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Top results area */
        .bottom-results {
            position: absolute;
            top: 41px;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: visible;
            display: none;
            height: calc(100vh - 41px);
        }

        /* Compact table styling */
        #chargers-table {
            border-collapse: collapse;
            line-height: 1;
            height: auto;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            width: 100%;
        }

        #chargers-table tr,
        #chargers-table tr td,
        #chargers-table tr th {
            height: 18px !important;
            line-height: 1 !important;
        }

        #chargers-table td,
        #chargers-table th {
            border-bottom: 1px solid #f3f4f6;
        }

        /* Compact list items */
        .compact-charger-item {
            margin-bottom: 8px !important;
            padding: 8px !important;
            border-radius: 6px;
            background: white;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .compact-charger-item h3 {
            font-size: 14px !important;
            margin-bottom: 4px !important;
            font-weight: 600;
        }

        .compact-charger-item p {
            font-size: 12px !important;
            margin-bottom: 2px !important;
            line-height: 1.3;
        }

        .compact-charger-item h4 {
            font-size: 13px !important;
            margin-bottom: 4px !important;
            font-weight: 600;
        }

        .compact-charger-item ul {
            margin: 0;
            padding: 0;
        }

        .compact-charger-item li {
            font-size: 11px !important;
            margin-bottom: 2px !important;
            line-height: 1.2;
        }

        /* Custom scrollbar for the results list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Table styles */
        #chargers-table {
            table-layout: fixed;
        }

        #chargers-table td {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .overlay-form {
                padding: 10px;
                max-height: 40vh;
                position: fixed;
                top: 0;
            }

            .bottom-results {
                padding: 0;
            }

            .compact-charger-item {
                margin-bottom: 6px !important;
                padding: 6px !important;
            }

            .drag-handle {
                width: 50px;
                height: 5px;
            }

            .show-list-bottom {
                padding: 6px 10px;
                font-size: 11px;
            }

            /* Table responsive design */
            #chargers-table {
                font-size: 10px;
            }

            #chargers-table th,
            #chargers-table td {
                padding: 4px 6px;
            }

            #chargers-table th:nth-child(3),
            #chargers-table td:nth-child(3) {
                display: none;
                /* Hide distance column on mobile */
            }

            #chargers-table th:nth-child(4),
            #chargers-table td:nth-child(4) {
                display: none;
                /* Hide stalls column on mobile */
            }
        }

        .autocomplete-suggestion {
            padding: 8px;
            cursor: pointer;
        }

        .autocomplete-suggestion:hover {
            background: #f0f0f0;
        }

        /* Custom emoji icons for map markers */
        .emoji-icon {
            font-size: 48px;
            line-height: 1;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            transform: translate(-50%, -50%);
            position: absolute;
            top: 50%;
            left: 50%;
        }

        /* Search highlight styling */
        mark {
            background-color: #fef3c7 !important;
            color: #000 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-weight: 600 !important;
        }

        /* Fullscreen map mode */
        .map-fullscreen {
            height: 100vh !important;
            width: 100vw !important;
        }

        .bottom-results-hidden {
            display: none !important;
        }

        /* Table styling for compact layout */
        #chargers-table {
            font-size: 12px;
            line-height: 1.2;
            width: 100%;
            margin: 0;
        }

        #chargers-table th {
            padding: 6px 8px;
            font-size: 11px;
        }

        #chargers-table td {
            padding: 6px 8px;
        }

        #chargers-table tbody tr {
            height: 32px;
        }
    </style>
</head>

<body class="bg-gray-100 font-sans antialiased">
    <div id="map" style="position: relative;">
    </div>

    <!-- Top Toolbar -->
    <div id="top-toolbar"
        class="fixed top-0 left-0 right-0 z-50 bg-white border-b border-gray-300 p-2 flex justify-center space-x-2">
        <button id="toggle-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">â–¼</button>
        <button id="new-search-btn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">New
            Search</button>
    </div>

    <!-- Top Results Area -->
    <div class="bottom-results" id="bottom-results">
        <div id="results-list" class="custom-scrollbar px-2"
            style="height: 100%; overflow-y: auto; overflow-x: hidden;">
            <!-- Restaurant Search -->
            <div class="mb-4 pt-4">
                <input type="text" id="restaurant-search"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
                    placeholder="Search restaurants...">
            </div>
            <table id="chargers-table" class="w-full hidden table-fixed">
                <thead class="sticky top-0 bg-white z-10">
                    <tr>
                        <th class="px-1 py-0 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-20">
                            Distance
                        </th>
                        <th class="px-1 py-0 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Nearby Restaurants</th>
                    </tr>
                </thead>
                <tbody id="chargers-tbody">
                </tbody>
            </table>
            <p id="no-results" class="text-gray-500">Search for a route to see results.</p>
        </div>
        <hr class="border-gray-300">
    </div>

    <!-- Overlay Input Form -->
    <div class="overlay-form" id="search-form">
        <header class="text-center mb-4">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">Passenger Princess Protector</h1>
        </header>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-end">
            <div class="relative">
                <label for="origin" class="block text-sm font-medium text-gray-700">Origin</label>
                <input type="text" id="origin"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
                    placeholder="e.g., San Francisco, CA">
                <div id="origin-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="relative">
                <label for="destination" class="block text-sm font-medium text-gray-700">Destination</label>
                <input type="text" id="destination"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
                    placeholder="e.g., Los Angeles, CA">
                <div id="destination-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="md:col-span-2">
                <button id="find-route-btn"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out text-sm">
                    Find Route & Amenities
                </button>
            </div>
        </div>
        <div id="status-message" class="text-center mt-3 text-gray-600 font-medium text-sm"></div>
    </div>

    <!-- Bottom Results Area -->
    <div class="bottom-results" id="bottom-results">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold text-gray-800">Superchargers & Restaurants</h2>
            <button id="new-search-btn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">
                New Search
            </button>
        </div>
        <div id="results-list">
            <p class="text-gray-500">Search for a route to see results.</p>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        // IMPORTANT: Get your free API key from https://openrouteservice.org/
        const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImVjNDQ2NWRmYWFiODQ3ZmVhMTM2NTNhODA0YjRiYWI4IiwiaCI6Im11cm11cjY0In0='
        // Distance in miles to search for chargers from the route
        const SEARCH_RADIUS_MILES = 5

        // --- DOM ELEMENTS ---
        const originInput = document.getElementById( 'origin' )
        const destinationInput = document.getElementById( 'destination' )
        const findRouteBtn = document.getElementById( 'find-route-btn' )
        const statusMessage = document.getElementById( 'status-message' )
        const mapElement = document.getElementById( 'map' )
        const originSuggestions = document.getElementById( 'origin-suggestions' )
        const destinationSuggestions = document.getElementById( 'destination-suggestions' )
        const searchForm = document.getElementById( 'search-form' )
        const bottomResults = document.getElementById( 'bottom-results' )
        const resultsList = document.getElementById( 'results-list' )
        const newSearchBtn = document.getElementById( 'new-search-btn' )

        // Check for query parameters and auto-populate search
        const urlParams = new URLSearchParams( window.location.search )
        const originParam = urlParams.get( 'origin' )
        const destinationParam = urlParams.get( 'destination' )

        if ( originParam && destinationParam ) {
            originInput.value = decodeURIComponent( originParam )
            destinationInput.value = decodeURIComponent( destinationParam )
            // Auto-trigger search after a short delay to ensure everything is loaded
            // Only if we're not already showing results
            if ( bottomResults.style.display === 'none' ) {
                setTimeout( () => {
                    handleRouteSearch()
                }, 500 )
            }
        }

        // --- MAP INITIALIZATION ---
        let map = L.map( mapElement, { zoomControl: false, zoomSnap: 0, zoomDelta: 1.5, wheelPxPerZoomLevel: 60 } ).setView( [ 37.7749, -122.4194 ], 6 ) // Default to SF
        L.tileLayer( 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        } ).addTo( map )

        let routeLayer = L.layerGroup().addTo( map )
        let chargerLayer = L.layerGroup().addTo( map )
        let restaurantLayer = L.layerGroup().addTo( map )

        // Store all markers for viewport filtering
        let allChargerMarkers = []
        let allRestaurantMarkers = []
        let currentChargers = []
        let currentRestaurants = []

        // Add map event listeners for viewport updates
        map.on( 'moveend zoomend', updateVisibleMarkers )

        // --- EVENT LISTENERS ---
        findRouteBtn.addEventListener( 'click', handleRouteSearch )
        newSearchBtn.addEventListener( 'click', () => {
            clearMap()
            originInput.value = ''
            destinationInput.value = ''
            restaurantSearchInput.value = ''
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
            toggleBtn.textContent = 'Show Results'
            updateStatus( '' )

            // Clear query parameters
            const url = new URL( window.location )
            url.searchParams.delete( 'origin' )
            url.searchParams.delete( 'destination' )
            window.history.pushState( {}, '', url )
        } )

        // Handle browser back/forward navigation
        window.addEventListener( 'popstate', () => {
            const urlParams = new URLSearchParams( window.location.search )
            const originParam = urlParams.get( 'origin' )
            const destinationParam = urlParams.get( 'destination' )

            if ( originParam && destinationParam ) {
                originInput.value = decodeURIComponent( originParam )
                destinationInput.value = decodeURIComponent( destinationParam )
                handleRouteSearch()
            } else {
                // Clear the form if no parameters
                clearMap()
                originInput.value = ''
                destinationInput.value = ''
                searchForm.style.display = 'block'
                bottomResults.style.display = 'none'
                updateStatus( '' )
            }
        } )

        // Button event listeners for results panel
        const toggleBtn = document.getElementById( 'toggle-btn' )
        toggleBtn.addEventListener( 'click', () => {
            if ( bottomResults.style.display === 'none' ) {
                // Show results
                bottomResults.style.display = 'block'
                bottomResults.style.height = 'calc(100vh - 41px)'
                toggleBtn.textContent = 'Hide Results'
                map.invalidateSize()
            } else {
                // Hide results
                bottomResults.style.display = 'none'
                toggleBtn.textContent = 'Show Results'
                map.invalidateSize()
            }
        } )

        // Restaurant search functionality
        const restaurantSearchInput = document.getElementById( 'restaurant-search' )
        restaurantSearchInput.addEventListener( 'input', () => {
            filterRestaurants( restaurantSearchInput.value )
        } )

        // Autocomplete for origin
        let originDebounceTimer
        originInput.addEventListener( 'input', () => {
            clearTimeout( originDebounceTimer )
            originDebounceTimer = setTimeout( () => fetchSuggestions( originInput.value, originSuggestions, originInput ), 300 )
        } )
        originInput.addEventListener( 'focus', () => {
            if ( originInput.value ) fetchSuggestions( originInput.value, originSuggestions, originInput )
        } )
        originInput.addEventListener( 'blur', () => setTimeout( () => originSuggestions.classList.add( 'hidden' ), 150 ) )

        // Autocomplete for destination
        let destinationDebounceTimer
        destinationInput.addEventListener( 'input', () => {
            clearTimeout( destinationDebounceTimer )
            destinationDebounceTimer = setTimeout( () => fetchSuggestions( destinationInput.value, destinationSuggestions, destinationInput ), 300 )
        } )
        destinationInput.addEventListener( 'focus', () => {
            if ( destinationInput.value ) fetchSuggestions( destinationInput.value, destinationSuggestions, destinationInput )
        } )
        destinationInput.addEventListener( 'blur', () => setTimeout( () => destinationSuggestions.classList.add( 'hidden' ), 150 ) )

        // --- CORE FUNCTIONS ---

        /**
         * Toggles between fullscreen and normal map view
         * @param {boolean} hideResults - If true, hide the results; if false, show them
         */
        function toggleFullscreen ( hideResults ) {
            isFullscreen = hideResults

            if ( hideResults ) {
                // Hide bottom results and make map fullscreen
                bottomResults.classList.add( 'bottom-results-hidden' )
                mapElement.classList.add( 'map-fullscreen' )
            } else {
                // Show bottom results and return to normal view
                bottomResults.classList.remove( 'bottom-results-hidden' )
                mapElement.classList.remove( 'map-fullscreen' )
            }

            // Trigger map resize to handle the new dimensions
            setTimeout( () => {
                map.invalidateSize()
            }, 100 )
        }

        /**
         * Main function to handle the route search process.
         */
        async function handleRouteSearch () {
            const origin = originInput.value.trim()
            const destination = destinationInput.value.trim()

            if ( !origin || !destination ) {
                updateStatus( "Please enter both an origin and a destination.", true )
                return
            }
            if ( ORS_API_KEY === 'YOUR_API_KEY_HERE' ) {
                updateStatus( "Please add your OpenRouteService API key to the script.", true )
                alert( "API Key missing. Please edit the HTML file and add your free API key from openrouteservice.org." )
                return
            }

            // Update URL with search parameters immediately
            const url = new URL( window.location )
            url.searchParams.set( 'origin', encodeURIComponent( origin ) )
            url.searchParams.set( 'destination', encodeURIComponent( destination ) )
            window.history.pushState( {}, '', url )

            // Clear previous results
            clearMap()
            updateStatus( "Finding route..." )

            // Hide table and show searching message
            const chargersTable = document.getElementById( 'chargers-table' )
            const noResults = document.getElementById( 'no-results' )
            if ( chargersTable ) chargersTable.classList.add( 'hidden' )
            if ( noResults ) {
                noResults.textContent = 'Searching...'
                noResults.classList.remove( 'hidden' )
            }

            // Hide search form and show results
            searchForm.style.display = 'none'
            bottomResults.style.display = 'block'
            bottomResults.style.height = 'calc(100vh - 41px)'
            toggleBtn.textContent = 'Hide Results'

            try {
                // Step 1: Geocode addresses to get coordinates
                const [ originCoords, destCoords ] = await Promise.all( [
                    geocodeAddress( origin ),
                    geocodeAddress( destination )
                ] )

                if ( !originCoords || !destCoords ) {
                    updateStatus( "Could not find one or both locations. Please be more specific.", true )
                    return
                }

                // Step 2: Fetch the route geometry
                updateStatus( "Calculating route..." )
                const routeData = await getRoute( originCoords, destCoords )
                const routeCoords = routeData.geometry.coordinates.map( c => [ c[ 1 ], c[ 0 ] ] ) // Flip coords for Leaflet
                drawRoute( routeCoords )
                map.fitBounds( L.polyline( routeCoords ).getBounds().pad( 0.1 ) )

                // Step 3: Fetch all Superchargers
                updateStatus( "Finding Superchargers..." )
                const allChargers = await getSuperchargers( routeCoords )

                // Step 4: Find chargers along the route
                const chargersOnRoute = findChargersNearRoute( allChargers, routeCoords, SEARCH_RADIUS_MILES )

                // Step 5: Display the results
                await displaySuperchargersAndRestaurants( chargersOnRoute )
                updateStatus( `Found ${ chargersOnRoute.length } Superchargers with restaurants.`, false )

                // Ensure map resizes properly
                setTimeout( () => {
                    map.invalidateSize()
                }, 100 )


            } catch ( error ) {
                console.error( "Error during route search:", error )
                if ( error.message && error.message.includes( "routable point" ) ) {
                    updateStatus( "Could not find a routable location near one of the addresses. Please try a different or more specific location.", true )
                } else {
                    updateStatus( "An error occurred. Please check the console for details.", true )
                }
            }
        }

        /**
         * Converts an address string to latitude/longitude coordinates.
         * @param {string} address The address to geocode.
         * @returns {Promise<[number, number]|null>} A promise resolving to [lon, lat] or null.
         */
        async function geocodeAddress ( address ) {
            const url = `https://api.openrouteservice.org/geocode/search?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( address ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( `Geocoding failed: ${ response.statusText }` )
            const data = await response.json()
            if ( data.features && data.features.length > 0 ) {
                return data.features[ 0 ].geometry.coordinates // [lon, lat]
            }
            return null
        }

        /**
         * Fetches autocomplete suggestions for an address.
         * @param {string} query The partial address query.
         * @param {HTMLElement} suggestionsDiv The div to display suggestions.
         * @param {HTMLElement} input The input element.
         */
        async function fetchSuggestions ( query, suggestionsDiv, input ) {
            if ( query.length < 3 ) {
                suggestionsDiv.classList.add( 'hidden' )
                return
            }
            try {
                const url = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( query ) }&size=5`
                const response = await fetch( url )
                if ( !response.ok ) throw new Error( `Autocomplete failed: ${ response.statusText }` )
                const data = await response.json()
                displaySuggestions( data.features, suggestionsDiv, input )
            } catch ( error ) {
                console.error( 'Autocomplete error:', error )
                suggestionsDiv.classList.add( 'hidden' )
            }
        }

        /**
         * Displays the suggestions in the dropdown.
         * @param {Array} features The geocoding features.
         * @param {HTMLElement} suggestionsDiv The div to display suggestions.
         * @param {HTMLElement} input The input element.
         */
        function displaySuggestions ( features, suggestionsDiv, input ) {
            suggestionsDiv.innerHTML = ''
            if ( features && features.length > 0 ) {
                features.forEach( feature => {
                    const suggestion = document.createElement( 'div' )
                    suggestion.className = 'autocomplete-suggestion'
                    suggestion.textContent = feature.properties.label
                    suggestion.addEventListener( 'click', () => {
                        input.value = feature.properties.label
                        suggestionsDiv.classList.add( 'hidden' )
                    } )
                    suggestionsDiv.appendChild( suggestion )
                } )
                suggestionsDiv.classList.remove( 'hidden' )
            } else {
                suggestionsDiv.classList.add( 'hidden' )
            }
        }

        /**
         * Fetches a route between two coordinates from OpenRouteService.
         * @param {[number, number]} startCoords [lon, lat] for the start point.
         * @param {[number, number]} endCoords [lon, lat] for the end point.
         * @returns {Promise<object>} A promise resolving to the route data.
         */
        async function getRoute ( startCoords, endCoords ) {
            const url = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson'
            const body = JSON.stringify( {
                "coordinates": [ startCoords, endCoords ],
                "radiuses": [ 5000, 5000 ]  // Allow snapping within 5km
            } )
            const response = await fetch( url, {
                method: 'POST',
                headers: {
                    'Authorization': ORS_API_KEY,
                    'Content-Type': 'application/json; charset=utf-8',
                    'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',
                },
                body: body
            } )
            if ( !response.ok ) throw new Error( `Routing failed: ${ response.statusText }` )
            const data = await response.json()
            return data.features[ 0 ]
        }

        /**
         * Fetches restaurants near multiple locations using sequential Overpass API requests for each amenity type.
         * @param {Array<{latitude: number, longitude: number}>} locations Array of GPS coordinates
         * @param {number} radius Radius in meters
         * @returns {Promise<Array<{locationIndex: number, restaurants: Array<object>}>>} Array of restaurant data grouped by location
         */
        async function getNearbyRestaurantsBulk ( locations, radius = 500 ) {
            if ( locations.length === 0 ) return []

            // Initialize results array
            const results = locations.map( ( loc, index ) => ( {
                locationIndex: index,
                restaurants: []
            } ) )

            // Build Overpass query with all amenity types for all locations
            let queryParts = []
            locations.forEach( ( loc, index ) => {
                queryParts.push( `
                    node["amenity"="restaurant"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="fast_food"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="cafe"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="bar"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="pub"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="food_court"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="ice_cream"](around:${ radius },${ loc.latitude },${ loc.longitude });
                    node["amenity"="bakery"](around:${ radius },${ loc.latitude },${ loc.longitude });` )
            } )

            const query = `
                [out:json][timeout:30];
                (
                    ${ queryParts.join( '\n' ) }
                );
                out;
            `


            try {
                // Use POST request to handle large query data
                const response = await fetch( 'https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: `data=${ encodeURIComponent( query ) }`
                } )
                if ( !response.ok ) throw new Error( "Failed to fetch restaurant data." )
                const data = await response.json()


                // Group restaurants by which location they're closest to
                data.elements.forEach( element => {
                    let closestIndex = 0
                    let closestDistance = Infinity

                    locations.forEach( ( loc, index ) => {
                        const distance = getDistance( loc.latitude, loc.longitude, element.lat, element.lon )
                        if ( distance < closestDistance ) {
                            closestDistance = distance
                            closestIndex = index
                        }
                    } )

                    if ( closestDistance <= radius ) {
                        results[ closestIndex ].restaurants.push( {
                            id: element.id,
                            name: element.tags?.name || `Restaurant ${ element.id }`,
                            cuisine: element.tags?.cuisine || 'Unknown',
                            address: {
                                street: element.tags?.[ 'addr:street' ] || '',
                                city: element.tags?.[ 'addr:city' ] || '',
                                state: element.tags?.[ 'addr:state' ] || ''
                            },
                            gps: {
                                latitude: element.lat,
                                longitude: element.lon
                            },
                            distance: closestDistance,
                            type: element.tags?.amenity || 'restaurant'
                        } )
                    }
                } )

            } catch ( error ) {
                console.warn( "Error fetching restaurant data:", error )
                // Return empty results if the query fails
            }

            // Sort restaurants by distance for each location (closest first)
            results.forEach( result => {
                result.restaurants.sort( ( a, b ) => a.distance - b.distance )
                console.log( `Location ${ result.locationIndex }: ${ result.restaurants.length } restaurants sorted by distance` )
            } )

            return results
        }
        async function getSuperchargers ( routeCoords = null ) {
            // Using Overpass API to query OpenStreetMap for Tesla Superchargers
            let query

            if ( routeCoords && routeCoords.length > 0 ) {
                // Calculate bounding box of the route
                let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity
                routeCoords.forEach( coord => {
                    minLat = Math.min( minLat, coord[ 0 ] )
                    maxLat = Math.max( maxLat, coord[ 0 ] )
                    minLon = Math.min( minLon, coord[ 1 ] )
                    maxLon = Math.max( maxLon, coord[ 1 ] )
                } )

                // Add padding (about 50km)
                const latPadding = 0.45 // ~50km
                const lonPadding = 0.45 // ~50km
                minLat -= latPadding
                maxLat += latPadding
                minLon -= lonPadding
                maxLon += lonPadding

                query = `
                    [out:json][timeout:30];
                    (
                        node["amenity"="charging_station"]["operator"~"Tesla"](${ minLat },${ minLon },${ maxLat },${ maxLon });
                        way["amenity"="charging_station"]["operator"~"Tesla"](${ minLat },${ minLon },${ maxLat },${ maxLon });
                        relation["amenity"="charging_station"]["operator"~"Tesla"](${ minLat },${ minLon },${ maxLat },${ maxLon });
                    );
                    out center meta;
                `
            } else {
                // Fallback: search in a smaller area (California)
                query = `
                    [out:json][timeout:30];
                    area["ISO3166-1"="US-CA"]->.ca;
                    (
                        node["amenity"="charging_station"]["operator"~"Tesla"](area.ca);
                        way["amenity"="charging_station"]["operator"~"Tesla"](area.ca);
                        relation["amenity"="charging_station"]["operator"~"Tesla"](area.ca);
                    );
                    out center meta;
                `
            }

            const url = `https://overpass-api.de/api/interpreter?data=${ encodeURIComponent( query ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( "Failed to fetch Supercharger data from OpenStreetMap." )
            const data = await response.json()

            // Transform OSM data to match expected format
            return data.elements.map( element => ( {
                id: element.id,
                name: element.tags?.name || `Tesla Supercharger ${ element.id }`,
                address: {
                    street: element.tags?.[ 'addr:street' ] || '',
                    city: element.tags?.[ 'addr:city' ] || '',
                    state: element.tags?.[ 'addr:state' ] || '',
                    zip: element.tags?.[ 'addr:postcode' ] || ''
                },
                gps: {
                    latitude: element.lat || element.center?.lat,
                    longitude: element.lon || element.center?.lon
                },
                status: element.tags?.opening_hours ? 'open' : 'unknown',
                stallCount: parseInt( element.tags?.capacity ) || 0
            } ) )
        }

        /**
         * Displays Superchargers and their nearby restaurants.
         * @param {Array<object>} chargers - The chargers to display.
         */

        /**
         * Filters a list of all chargers to find those within a certain radius of the route.
         * @param {Array<object>} allChargers - Array of all supercharger sites.
         * @param {Array<[number, number]>} routeCoords - Array of [lat, lon] points for the route.
         * @param {number} radiusMiles - The search radius in miles.
         * @returns {Array<object>} An array of filtered charger objects.
         */
        function findChargersNearRoute ( allChargers, routeCoords, radiusMiles ) {
            const chargersOnRoute = []
            for ( const charger of allChargers ) {
                if ( charger.gps ) {
                    const chargerPoint = { lat: charger.gps.latitude, lng: charger.gps.longitude }

                    // Check distance to route segments
                    for ( let i = 0; i < routeCoords.length - 1; i++ ) {
                        const segmentStart = { lat: routeCoords[ i ][ 0 ], lng: routeCoords[ i ][ 1 ] }
                        const segmentEnd = { lat: routeCoords[ i + 1 ][ 0 ], lng: routeCoords[ i + 1 ][ 1 ] }
                        const segmentDistance = pointToLineSegmentDistance( chargerPoint, segmentStart, segmentEnd )

                        if ( segmentDistance <= radiusMiles ) {
                            chargersOnRoute.push( charger )
                            break
                        }
                    }

                    // Also check distance to individual route points (every 10th point to optimize)
                    if ( chargersOnRoute.indexOf( charger ) === -1 ) {
                        for ( let i = 0; i < routeCoords.length; i += 10 ) {
                            const routePoint = { lat: routeCoords[ i ][ 0 ], lng: routeCoords[ i ][ 1 ] }
                            const pointDistance = distance( chargerPoint.lat, chargerPoint.lng, routePoint.lat, routePoint.lng )

                            if ( pointDistance <= radiusMiles ) {
                                chargersOnRoute.push( charger )
                                break
                            }
                        }
                    }
                }
            }
            return chargersOnRoute
        }

        /**
         * Displays Superchargers and their nearby restaurants.
         * @param {Array<object>} chargers - The chargers to display.
         */
        async function displaySuperchargersAndRestaurants ( chargers ) {
            if ( chargers.length === 0 ) {
                const chargersTable = document.getElementById( 'chargers-table' )
                const noResults = document.getElementById( 'no-results' )
                if ( chargersTable ) chargersTable.classList.add( 'hidden' )
                if ( noResults ) {
                    noResults.textContent = 'No Superchargers found within 1km of your route.'
                    noResults.classList.remove( 'hidden' )
                }
                return
            }

            // Sort chargers by distance from origin
            const originElement = document.getElementById( 'origin' )
            const originCoords = originElement ? await geocodeAddress( originElement.value.trim() ) : null

            if ( originCoords ) {
                chargers.sort( ( a, b ) => {
                    const distA = distance( originCoords[ 1 ], originCoords[ 0 ], a.gps.latitude, a.gps.longitude )
                    const distB = distance( originCoords[ 1 ], originCoords[ 0 ], b.gps.latitude, b.gps.longitude )
                    return distA - distB
                } )
            }

            // Clear previous data
            allChargerMarkers = []
            allRestaurantMarkers = []
            currentChargers = chargers

            // Show table, hide no results message
            const chargersTable = document.getElementById( 'chargers-table' )
            const noResults = document.getElementById( 'no-results' )
            if ( chargersTable ) chargersTable.classList.remove( 'hidden' )
            if ( noResults ) noResults.classList.add( 'hidden' )

            const tbody = document.getElementById( 'chargers-tbody' )
            if ( tbody ) tbody.innerHTML = ''

            // Extract locations for bulk restaurant query
            const locations = chargers.map( charger => charger.gps )

            // Show loading message for restaurants
            if ( noResults ) {
                noResults.textContent = 'Retrieving restaurant info...'
                noResults.classList.remove( 'hidden' )
            }

            // Fetch all restaurants in one request
            const bulkResults = await getNearbyRestaurantsBulk( locations, 500 )

            // Hide loading message
            if ( noResults ) {
                noResults.classList.add( 'hidden' )
            }

            // Use document fragment for better performance
            const fragment = document.createDocumentFragment()

            // Process results and create table rows
            chargers.forEach( ( charger, index ) => {
                const chargerLatLng = [ charger.gps.latitude, charger.gps.longitude ]
                const marker = L.marker( chargerLatLng, {
                    icon: L.divIcon( {
                        className: 'emoji-icon',
                        html: 'âš¡',
                        iconSize: [ 100, 100 ],
                        iconAnchor: [ 50, 50 ]
                    } )
                } )

                // Store marker for later viewport filtering
                allChargerMarkers.push( marker )

                // Get restaurants for this charger
                const restaurants = bulkResults[ index ]?.restaurants || []

                // Calculate distance from origin
                let distanceFromOrigin = 'N/A'
                if ( originCoords ) {
                    distanceFromOrigin = distance(
                        originCoords[ 1 ], originCoords[ 0 ],
                        charger.gps.latitude, charger.gps.longitude
                    ).toFixed( 1 ) + ' mi'
                }

                // Add restaurant markers
                restaurants.forEach( restaurant => {
                    const restaurantLatLng = [ restaurant.gps.latitude, restaurant.gps.longitude ]
                    const restaurantMarker = L.marker( restaurantLatLng, {
                        icon: L.divIcon( {
                            className: 'emoji-icon',
                            html: 'ðŸŒ­',
                            iconSize: [ 70, 70 ],
                            iconAnchor: [ 35, 35 ]
                        } )
                    } )
                    restaurantMarker.bindPopup( `<strong>${ restaurant.name }</strong><br>${ restaurant.cuisine || 'Restaurant' }<br>${ restaurant.distance }m away` )

                    // Handle popup close - just close the popup, don't remove marker
                    restaurantMarker.on( 'popupclose', function () {
                        // Marker stays on map, just popup closes
                    } )

                    allRestaurantMarkers.push( restaurantMarker )
                } )

                // Create popup content
                let popupContent = `
                    <div class="font-sans max-w-xs">
                        <strong class="text-lg">${ charger.name }</strong><br>
                        <strong>Status:</strong> ${ charger.status }<br>
                        <strong>Stalls:</strong> ${ charger.stallCount }<br>
                        <strong>Distance from origin:</strong> ${ distanceFromOrigin }<br>
                        <a href="https://www.google.com/maps/search/?api=1&query=${ charger.gps.latitude },${ charger.gps.longitude }" target="_blank" class="text-blue-500 hover:underline text-sm">Open in Google Maps</a>
                `

                if ( restaurants.length > 0 ) {
                    popupContent += '<br><br><strong>Nearby Restaurants:</strong><br>'
                    const displayRestaurants = restaurants.slice( 0, 10 )
                    displayRestaurants.forEach( restaurant => {
                        popupContent += `<div class="text-sm mt-1">â€¢ ${ restaurant.name } (${ restaurant.cuisine || 'Restaurant' }) - ${ restaurant.distance }m</div>`
                    } )
                    if ( restaurants.length > 10 ) {
                        const moreCount = restaurants.length - 10
                        popupContent += `<div class="text-sm mt-1 text-gray-600">and ${ moreCount } more...</div>`
                    }
                }

                popupContent += '</div>'
                marker.bindPopup( popupContent )

                // Handle popup close - just close the popup, don't remove marker
                marker.on( 'popupclose', function () {
                    // Marker stays on map, just popup closes
                } )

                // Create table rows - main charger row
                const chargerRow = document.createElement( 'tr' )
                chargerRow.className = 'cursor-pointer'

                if ( restaurants.length > 0 ) {
                    chargerRow.innerHTML = `
                        <td class="px-1 py-0 text-sm text-gray-500 border-r border-gray-200" rowspan="${ restaurants.length }">${ distanceFromOrigin }</td>
                        <td class="px-1 py-0 text-sm text-gray-700">
                            ${ restaurants[ 0 ].name } (${ restaurants[ 0 ].distance }m)
                        </td>
                    `
                } else {
                    chargerRow.innerHTML = `
                        <td class="px-1 py-0 text-sm text-gray-500 border-r border-gray-200">${ distanceFromOrigin }</td>
                        <td class="px-1 py-0 text-sm text-gray-700">
                            No restaurants found
                        </td>
                    `
                }

                chargerRow.addEventListener( 'click', () => {
                    // Check if marker is within map bounds before opening popup
                    if ( map.getBounds().contains( chargerLatLng ) ) {
                        map.setView( chargerLatLng, 15 )
                        marker.openPopup()
                        // Hide the results list
                        bottomResults.style.display = 'none'
                        toggleBtn.textContent = 'Show Results'
                        map.invalidateSize()
                    }
                } )

                fragment.appendChild( chargerRow )

                // Create subrows for additional restaurants
                for ( let i = 1; i < restaurants.length; i++ ) {
                    const restaurantRow = document.createElement( 'tr' )
                    restaurantRow.className = 'cursor-pointer'
                    restaurantRow.innerHTML = `
                        <td class="px-1 py-0 text-sm text-gray-700">
                            ${ restaurants[ i ].name } (${ restaurants[ i ].distance }m)
                        </td>
                    `

                    restaurantRow.addEventListener( 'click', () => {
                        map.setView( chargerLatLng, 15 )
                        marker.openPopup()
                        // Hide the results list
                        bottomResults.style.display = 'none'
                        toggleBtn.textContent = 'Show Results'
                        map.invalidateSize()
                    } )

                    fragment.appendChild( restaurantRow )
                }
            } )

            // Append all rows at once for better performance
            tbody.appendChild( fragment )

            // Add markers to map for current viewport
            updateVisibleMarkers()
        }

        /**
         * Display superchargers only (without restaurants) for initial load
         * @param {Array<object>} chargers - The chargers to display.
         */
        async function displaySuperchargersOnly ( chargers ) {
            if ( chargers.length === 0 ) return

            // Clear previous data
            allChargerMarkers = []
            currentChargers = chargers

            // Create markers for all chargers
            chargers.forEach( ( charger ) => {
                const chargerLatLng = [ charger.gps.latitude, charger.gps.longitude ]
                const marker = L.marker( chargerLatLng, {
                    icon: L.divIcon( {
                        className: 'emoji-icon',
                        html: 'âš¡',
                        iconSize: [ 100, 100 ],
                        iconAnchor: [ 50, 50 ]
                    } )
                } )

                // Create popup content
                const popupContent = `
                    <div class="font-sans max-w-xs">
                        <strong class="text-lg">${ charger.name }</strong><br>
                        <strong>Status:</strong> ${ charger.status }<br>
                        <strong>Stalls:</strong> ${ charger.stallCount }<br>
                        <a href="https://www.google.com/maps/search/?api=1&query=${ charger.gps.latitude },${ charger.gps.longitude }" target="_blank" class="text-blue-500 hover:underline text-sm">Open in Google Maps</a>
                    </div>
                `

                marker.bindPopup( popupContent )
                allChargerMarkers.push( marker )
            } )

            // Update visible markers based on current viewport
            updateVisibleMarkers()
        }


        // --- VIEWPORT MANAGEMENT ---

        function updateVisibleMarkers () {
            const bounds = map.getBounds()
            const zoom = map.getZoom()

            // For superchargers - keep them persistent, only add when they come into view
            allChargerMarkers.forEach( marker => {
                if ( bounds.contains( marker.getLatLng() ) && !chargerLayer.hasLayer( marker ) ) {
                    chargerLayer.addLayer( marker )
                } else if ( !bounds.contains( marker.getLatLng() ) && chargerLayer.hasLayer( marker ) ) {
                    chargerLayer.removeLayer( marker )
                }
            } )

            // For restaurants - only show when zoomed in enough
            if ( zoom >= 14 ) {
                allRestaurantMarkers.forEach( marker => {
                    if ( bounds.contains( marker.getLatLng() ) && !restaurantLayer.hasLayer( marker ) ) {
                        restaurantLayer.addLayer( marker )
                    } else if ( !bounds.contains( marker.getLatLng() ) && restaurantLayer.hasLayer( marker ) ) {
                        restaurantLayer.removeLayer( marker )
                    }
                } )
            } else {
                // Remove all restaurant markers when zoomed out
                restaurantLayer.clearLayers()
            }
        }

        function drawRoute ( coords ) {
            L.polyline( coords, { color: 'blue', weight: 5, opacity: 0.7 } ).addTo( routeLayer )
        }

        function clearMap () {
            routeLayer.clearLayers()
            chargerLayer.clearLayers()
            restaurantLayer.clearLayers()
            // Show search form and hide results
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
            toggleBtn.textContent = 'Show Results'
        }

        function updateStatus ( message, isError = false ) {
            statusMessage.textContent = message
            statusMessage.className = isError
                ? 'text-center mt-4 text-red-600 font-medium'
                : 'text-center mt-4 text-gray-600 font-medium'
        }

        // --- GEOMETRY HELPER FUNCTIONS ---

        /**
         * Calculates the shortest distance from a point to a line segment in miles.
         * @param {{lat: number, lng: number}} p - The point.
         * @param {{lat: number, lng: number}} a - Start point of the line segment.
         * @param {{lat: number, lng: number}} b - End point of the line segment.
         * @returns {number} The distance in miles.
         */
        function pointToLineSegmentDistance ( p, a, b ) {
            const l2 = latLngDistSqr( a, b )
            if ( l2 == 0 ) return distance( p.lat, p.lng, a.lat, a.lng )

            let t = ( ( p.lat - a.lat ) * ( b.lat - a.lat ) + ( p.lng - a.lng ) * ( b.lng - a.lng ) ) / l2
            t = Math.max( 0, Math.min( 1, t ) )

            const projection = {
                lat: a.lat + t * ( b.lat - a.lat ),
                lng: a.lng + t * ( b.lng - a.lng )
            }

            return distance( p.lat, p.lng, projection.lat, projection.lng )
        }

        function latLngDistSqr ( p1, p2 ) {
            const dx = p1.lat - p2.lat
            const dy = p1.lng - p2.lng
            return dx * dx + dy * dy
        }

        /**
         * Calculates distance between two lat/lon points using Haversine formula.
         * @returns {number} Distance in miles.
         */
        function distance ( lat1, lon1, lat2, lon2 ) {
            const R = 3958.8 // Radius of the Earth in miles
            const dLat = ( lat2 - lat1 ) * Math.PI / 180
            const dLon = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( dLat / 2 ) * Math.sin( dLat / 2 ) +
                Math.cos( lat1 * Math.PI / 180 ) * Math.cos( lat2 * Math.PI / 180 ) *
                Math.sin( dLon / 2 ) * Math.sin( dLon / 2 )
            const c = 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) )
            return R * c
        }

        /**
         * Calculates distance between two lat/lon points in meters.
         * @returns {number} Distance in meters.
         */
        function getDistance ( lat1, lon1, lat2, lon2 ) {
            const R = 6371000 // Radius of the Earth in meters
            const dLat = ( lat2 - lat1 ) * Math.PI / 180
            const dLon = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( dLat / 2 ) * Math.sin( dLat / 2 ) +
                Math.cos( lat1 * Math.PI / 180 ) * Math.cos( lat2 * Math.PI / 180 ) *
                Math.sin( dLon / 2 ) * Math.sin( dLon / 2 )
            const c = 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) )
            return Math.round( R * c )
        }

        /**
         * Filters restaurant table rows based on search input
         * @param {string} searchTerm The search term to filter by
         */
        function filterRestaurants ( searchTerm ) {
            const tbody = document.getElementById( 'chargers-tbody' )
            if ( !tbody ) return

            const rows = tbody.querySelectorAll( 'tr' )
            const searchLower = searchTerm.toLowerCase()

            // First pass: remove all highlights
            rows.forEach( row => {
                const cells = row.querySelectorAll( 'td' )
                cells.forEach( cell => {
                    cell.innerHTML = cell.innerHTML.replace( /<mark[^>]*>(.*?)<\/mark>/g, '$1' )
                } )
            } )

            if ( !searchTerm ) {
                // If no search term, show everything without highlights
                rows.forEach( row => {
                    row.style.display = ''
                } )
                return
            }

            // Second pass: process each supercharger group sequentially
            let currentIndex = 0
            while ( currentIndex < rows.length ) {
                const row = rows[ currentIndex ]
                const cells = row.querySelectorAll( 'td' )

                if ( cells.length === 0 ) {
                    currentIndex++
                    continue
                }

                // Check if this is a main charger row (has rowspan in first cell)
                const isMainRow = cells[ 0 ].hasAttribute( 'rowspan' )

                if ( isMainRow ) {
                    // This is a main charger row - check all its restaurants
                    const chargerRestaurants = []
                    const rowspan = parseInt( cells[ 0 ].getAttribute( 'rowspan' ) ) || 1

                    // Add restaurant from main row
                    if ( cells.length > 1 ) {
                        chargerRestaurants.push( cells[ 1 ].textContent )
                    }

                    // Add restaurants from sub-rows
                    for ( let i = 1; i < rowspan; i++ ) {
                        const subRow = rows[ currentIndex + i ]
                        if ( subRow ) {
                            const subCells = subRow.querySelectorAll( 'td' )
                            if ( subCells.length > 0 ) {
                                chargerRestaurants.push( subCells[ 0 ].textContent )
                            }
                        }
                    }

                    // Check if any restaurant matches
                    const hasMatch = chargerRestaurants.some( restaurant =>
                        restaurant.toLowerCase().includes( searchLower )
                    )

                    if ( hasMatch ) {
                        // Show this supercharger group and highlight matches

                        // Highlight main row restaurant
                        if ( cells.length > 1 ) {
                            const restaurantText = cells[ 1 ].textContent
                            if ( restaurantText.toLowerCase().includes( searchLower ) ) {
                                const highlightedText = restaurantText.replace(
                                    new RegExp( `(${ searchTerm })`, 'gi' ),
                                    '<mark class="bg-yellow-200 px-1 rounded">$1</mark>'
                                )
                                cells[ 1 ].innerHTML = highlightedText
                            }
                        }
                        row.style.display = ''

                        // Show and highlight sub-rows
                        for ( let i = 1; i < rowspan; i++ ) {
                            const subRow = rows[ currentIndex + i ]
                            if ( subRow ) {
                                const subCells = subRow.querySelectorAll( 'td' )
                                if ( subCells.length > 0 ) {
                                    const subRestaurantText = subCells[ 0 ].textContent
                                    if ( subRestaurantText.toLowerCase().includes( searchLower ) ) {
                                        const highlightedText = subRestaurantText.replace(
                                            new RegExp( `(${ searchTerm })`, 'gi' ),
                                            '<mark class="bg-yellow-200 px-1 rounded">$1</mark>'
                                        )
                                        subCells[ 0 ].innerHTML = highlightedText
                                    }
                                }
                                subRow.style.display = ''
                            }
                        }

                        // Move to next supercharger group
                        currentIndex += rowspan
                    } else {
                        // Hide this entire supercharger group
                        row.style.display = 'none'
                        for ( let i = 1; i < rowspan; i++ ) {
                            const subRow = rows[ currentIndex + i ]
                            if ( subRow ) {
                                subRow.style.display = 'none'
                            }
                        }

                        // Move to next supercharger group
                        currentIndex += rowspan
                    }
                } else {
                    // This shouldn't happen in a properly formed table, but skip if we encounter a row without rowspan
                    row.style.display = 'none'
                    currentIndex++
                }
            }
        }

    </script>

</body>

</html>