<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passenger Princess Protector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        .font-dancing {
            font-family: 'Dancing Script', cursive;
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        /* Full screen map */
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: calc(100vh - 60px);
            width: 100vw;
            position: absolute;
            top: 60px;
            margin: 0;
            padding: 0;
        }

        /* Overlay form at bottom */
        .overlay-form {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            width: 100vw;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 60px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Top results area */
        .bottom-results {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 1100;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
            height: calc(100vh - 60px);
        }

        /* Compact table styling */
        #chargers-table {
            border-collapse: collapse;
            line-height: 1;
            height: auto;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            width: 100%;
        }

        #chargers-table tr,
        #chargers-table tr td,
        #chargers-table tr th {
            height: 18px !important;
            line-height: 1 !important;
        }

        #chargers-table td,
        #chargers-table th {
            border-bottom: 2px solid #f3f4f6;
        }

        /* Compact list items */
        .compact-charger-item {
            margin-bottom: 8px !important;
            padding: 8px !important;
            border-radius: 6px;
            background: white;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .compact-charger-item h3 {
            font-size: 14px !important;
            margin-bottom: 4px !important;
            font-weight: 600;
        }

        .compact-charger-item p {
            font-size: 12px !important;
            margin-bottom: 2px !important;
            line-height: 1.3;
        }

        .compact-charger-item h4 {
            font-size: 13px !important;
            margin-bottom: 4px !important;
            font-weight: 600;
        }

        .compact-charger-item ul {
            margin: 0;
            padding: 0;
        }

        .compact-charger-item li {
            font-size: 11px !important;
            margin-bottom: 2px !important;
            line-height: 1.2;
        }

        /* Custom scrollbar for the results list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Table styles */
        #chargers-table {
            table-layout: fixed;
        }

        #chargers-table td {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .overlay-form {
                padding: 10px;
                max-height: 40vh;
                position: fixed;
                top: 0;
            }

            .bottom-results {
                padding: 0;
            }

            .compact-charger-item {
                margin-bottom: 6px !important;
                padding: 6px !important;
            }

            .drag-handle {
                width: 50px;
                height: 5px;
            }

            .show-list-bottom {
                padding: 6px 10px;
                font-size: 11px;
            }

            /* Table responsive design */
            #chargers-table {
                font-size: 10px;
            }

            #chargers-table th,
            #chargers-table td {
                padding: 4px 6px;
            }

            #chargers-table th:nth-child(3),
            #chargers-table td:nth-child(3) {
                display: none;
                /* Hide distance column on mobile */
            }

            #chargers-table th:nth-child(4),
            #chargers-table td:nth-child(4) {
                display: none;
                /* Hide stalls column on mobile */
            }
        }

        .autocomplete-suggestions {
            position: fixed;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1100;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 2px;
        }

        .autocomplete-suggestion {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.15s ease-in-out;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestion:hover {
            background: #f8fafc;
        }

        /* Enhanced link styling for clickable results */
        .city-link,
        .restaurant-link {
            text-decoration: underline;
            text-decoration-color: rgba(236, 72, 153, 0.5);
            text-underline-offset: 2px;
        }

        .city-link:hover,
        .restaurant-link:hover {
            text-decoration-color: rgb(236, 72, 153);
        }

        /* Custom emoji icons for map markers */
        .emoji-icon {
            font-size: 24px;
            line-height: 1;
            text-align: center;
            /* Simple shadow for better visibility */
            text-shadow: 0 0 3px white, 0 0 5px white;
        }

        /* Search highlight styling */
        mark {
            background-color: #fef3c7 !important;
            color: #000 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-weight: 600 !important;
        }

        /* Loading spinner styles */
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #ec4899;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Hide table headers when loading */
        #loading-container:not(.hidden)~#chargers-table thead {
            display: none;
        }

        /* Princess marker styling */
        .princess-marker {
            background: transparent !important;
            border: none !important;
            font-size: 36px !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body class="bg-pink-100 font-sans antialiased">
    <div id="map"></div>

    <div id="top-toolbar"
        class="fixed top-0 left-0 right-0 z-50 bg-gradient-to-r from-pink-200 to-pink-300 border-b border-pink-400 p-3 flex justify-between items-center shadow-lg">
        <div class="text-2xl font-bold text-pink-800 font-dancing">PPP</div>
        <div class="flex space-x-2">
            <button id="toggle-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition-all duration-200">â–¼</button>
            <button id="new-search-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition-all duration-200">New
                Search</button>
        </div>
    </div>

    <div class="bottom-results" id="bottom-results">
        <div id="results-list" class="custom-scrollbar px-2"
            style="height: 100%; overflow-y: auto; overflow-x: hidden;">
            <div class="mb-4 pt-4">
                <input type="text" id="restaurant-search"
                    class="w-full px-4 py-3 border border-pink-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-pink-500 text-sm enhanced-input"
                    placeholder="Search restaurants...">
            </div>

            <div id="loading-container" class="loading-container hidden">
                <div class="spinner"></div>
                <p class="loading-text" id="loading-text">Retrieving superchargers...</p>
            </div>

            <table id="chargers-table" class="w-full hidden table-fixed">
                <thead class="sticky top-0 bg-white z-10">
                    <tr>
                        <th class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-20">
                            Distance
                        </th>
                        <th class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider">
                            Nearby Restaurants</th>
                    </tr>
                </thead>
                <tbody id="chargers-tbody">
                </tbody>
            </table>
            <p id="no-results" class="text-pink-500">Search for a route to see results.</p>
        </div>
        <hr class="border-pink-300">
    </div>

    <div class="overlay-form" id="search-form">
        <header class="text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold text-pink-800 font-dancing">Passenger Princess Protector</h1>
        </header>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-end">
            <div class="relative">
                <div class="flex items-center justify-between mb-1">
                    <label for="origin" class="block text-sm font-medium text-pink-700">Origin</label>
                    <button id="location-btn"
                        class="bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white px-3 py-1 rounded-md text-xs font-medium focus:outline-none disabled:opacity-50 whitespace-nowrap shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition-all duration-200">
                        <span id="location-text">ðŸ‘‘ Use Current Location</span>
                        <div id="loading-spinner"
                            class="hidden w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin inline-block ml-2">
                        </div>
                    </button>
                </div>
                <input type="text" id="origin"
                    class="block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm enhanced-input"
                    placeholder="e.g., San Francisco, CA">
                <div id="origin-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="relative">
                <label for="destination" class="block text-sm font-medium text-pink-700">Destination</label>
                <input type="text" id="destination"
                    class="mt-1 block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm enhanced-input"
                    placeholder="e.g., Los Angeles, CA">
                <div id="destination-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="md:col-span-2">
                <button id="find-route-btn"
                    class="w-full bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all duration-200 text-sm hover:shadow-lg transform hover:-translate-y-0.5">
                    Find Route & Amenities
                </button>
            </div>
        </div>
        <div id="status-message" class="text-center mt-3 text-pink-600 font-medium text-sm"></div>
    </div>

    <div id="new-search-modal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[1200] hidden">
        <div class="bg-white rounded-lg p-6 max-w-sm mx-4 shadow-xl">
            <h3 class="text-lg font-semibold text-pink-800 mb-4 font-dancing">Are you sure?</h3>
            <p class="text-gray-600 mb-6">This will clear your current search and start a new one.</p>
            <div class="flex space-x-3 justify-end">
                <button id="cancel-new-search"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium">Cancel</button>
                <button id="confirm-new-search"
                    class="px-4 py-2 bg-pink-500 hover:bg-pink-600 text-white rounded-lg font-medium">Yes, New
                    Search</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImVjNDQ2NWRmYWFiODQ3ZmVhMTM2NTNhODA0YjRiYWI4IiwiaCI6Im11cm11cjY0In0=' // IMPORTANT: Get your free API key from https://openrouteservice.org/
        const SEARCH_RADIUS_MILES = 5

        // --- DOM ELEMENTS ---
        const originInput = document.getElementById( 'origin' )
        const destinationInput = document.getElementById( 'destination' )
        const findRouteBtn = document.getElementById( 'find-route-btn' )
        const statusMessage = document.getElementById( 'status-message' )
        const mapElement = document.getElementById( 'map' )
        const originSuggestions = document.getElementById( 'origin-suggestions' )
        const destinationSuggestions = document.getElementById( 'destination-suggestions' )
        const searchForm = document.getElementById( 'search-form' )
        const bottomResults = document.getElementById( 'bottom-results' )
        const newSearchBtn = document.getElementById( 'new-search-btn' )
        const locationBtn = document.getElementById( 'location-btn' )
        const locationText = document.getElementById( 'location-text' )
        const loadingSpinner = document.getElementById( 'loading-spinner' )
        const restaurantSearchInput = document.getElementById( 'restaurant-search' )

        // --- MAP INITIALIZATION ---
        let map = L.map( mapElement, {
            zoomControl: false,
            zoomSnap: 0.5,
            zoomDelta: 1
        } ).setView( [ 37.7749, -122.4194 ], 6 ) // Default to SF
        L.tileLayer( 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        } ).addTo( map )

        // Map Layers
        const routeLayer = L.layerGroup().addTo( map )
        const chargerLayer = L.layerGroup().addTo( map )
        const restaurantLayer = L.layerGroup().addTo( map )
        const userLocationLayer = L.layerGroup().addTo( map )

        // --- STATE MANAGEMENT ---
        let userLocationMarker = null
        // The single source of truth for all station data.
        // Each object contains all info: charger data, restaurant data, and map markers.
        let stationData = []
        // Tracks the current filter state. `null` means no filter, an array of IDs means filter is active.
        let filteredChargerIDs = null
        let currentSearchTerm = ''


        // --- EVENT LISTENERS ---
        findRouteBtn.addEventListener( 'click', handleRouteSearch )
        locationBtn.addEventListener( 'click', handleLocationClick )
        restaurantSearchInput.addEventListener( 'input', () => {
            filterListAndMap( restaurantSearchInput.value )
        } )

        // Update map markers when the user pans or zooms
        map.on( 'moveend zoomend', updateVisibleMarkers );

        // --- AUTO-SEARCH FROM URL PARAMS ---
        ( function autoSearchFromUrl () {
            const urlParams = new URLSearchParams( window.location.search )
            const originParam = urlParams.get( 'origin' )
            const destinationParam = urlParams.get( 'destination' )
            if ( originParam && destinationParam ) {
                originInput.value = decodeURIComponent( originParam )
                destinationInput.value = decodeURIComponent( destinationParam )
                setTimeout( () => handleRouteSearch(), 500 )
            }
        } )()

        // --- CORE APPLICATION LOGIC ---

        /**
         * Main function to handle the entire search process.
         */
        async function handleRouteSearch () {
            const origin = originInput.value.trim()
            const destination = destinationInput.value.trim()

            if ( !origin || !destination ) {
                updateStatus( "Please enter both an origin and a destination.", true )
                return
            }
            if ( ORS_API_KEY === 'YOUR_OPENROUTESERVICE_API_KEY' ) {
                updateStatus( "Please add your OpenRouteService API key to the script.", true )
                alert( "API Key missing. Please edit the HTML file and add your free API key from openrouteservice.org." )
                return
            }

            // Update URL and UI for search start
            updateUrlForSearch( origin, destination )
            clearPreviousResults()
            showLoadingState( "Finding route..." )

            try {
                // Step 1: Geocode addresses to get coordinates
                const [ originCoords, destCoords ] = await Promise.all( [
                    geocodeAddress( origin ),
                    geocodeAddress( destination )
                ] )
                if ( !originCoords || !destCoords ) {
                    throw new Error( "Could not find one or both locations. Please be more specific." )
                }

                // Step 2: Fetch and draw the route
                showLoadingState( "Calculating route..." )
                const routeData = await getRoute( originCoords, destCoords )
                const routeCoords = routeData.geometry.coordinates.map( c => [ c[ 1 ], c[ 0 ] ] )
                drawRoute( routeCoords )
                map.fitBounds( L.polyline( routeCoords ).getBounds().pad( 0.1 ) )

                // Step 3: Find chargers along the route
                showLoadingState( "Retrieving superchargers..." )
                const allChargers = await getSuperchargers( routeCoords )
                const chargersOnRoute = findChargersNearRoute( allChargers, routeCoords, SEARCH_RADIUS_MILES )

                // Step 4: Fetch restaurants and build the final data structure
                showLoadingState( "Retrieving restaurants..." )
                await processAndDisplayResults( chargersOnRoute, originCoords )

                updateStatus( `Found ${ stationData.length } Superchargers with restaurants.`, false )

            } catch ( error ) {
                console.error( "Error during route search:", error )
                const userMessage = error.message.includes( "routable point" ) ?
                    "Could not find a route. Please try a different or more specific location." :
                    "An error occurred. Please check your locations and try again."
                showErrorState( userMessage )
            }
        }

        /**
         * Takes chargers, fetches restaurants, sorts, and builds the UI.
         * This function creates the master `stationData` array.
         */
        async function processAndDisplayResults ( chargers, originCoords ) {
            if ( chargers.length === 0 ) {
                showEmptyState( "No Superchargers found near your route." )
                return
            }

            // Fetch restaurants for all chargers in a single batch
            const locations = chargers.map( c => c.gps )
            const restaurantResults = await getNearbyRestaurantsBulk( locations )

            // Combine chargers with their restaurants
            let combinedData = chargers.map( ( charger, index ) => ( {
                charger,
                restaurants: restaurantResults[ index ]?.restaurants || []
            } ) )

            // Sort by distance from the trip's origin
            combinedData.sort( ( a, b ) => {
                const distA = distance( originCoords[ 1 ], originCoords[ 0 ], a.charger.gps.latitude, a.charger.gps.longitude )
                const distB = distance( originCoords[ 1 ], originCoords[ 0 ], b.charger.gps.latitude, b.charger.gps.longitude )
                return distA - distB
            } )

            // Reset state and build the new `stationData` and table UI
            stationData = []
            const tbody = document.getElementById( 'chargers-tbody' )
            tbody.innerHTML = ''
            const fragment = document.createDocumentFragment()

            combinedData.forEach( ( { charger, restaurants } ) => {
                // Create map markers for this station
                const chargerMarker = createChargerMarker( charger, restaurants, originCoords )
                const restaurantMarkers = createRestaurantMarkers( restaurants )

                // Add the complete station object to our master data array
                stationData.push( {
                    id: charger.id.toString(), // Use ID as a string for consistency
                    chargerInfo: charger,
                    restaurants: restaurants,
                    chargerMarker: chargerMarker,
                    restaurantMarkers: restaurantMarkers,
                } )

                // Create and append the table row(s) for this station to the document fragment
                const tableRows = createTableRowsForStation( charger, restaurants, originCoords )
                tableRows.forEach( row => fragment.appendChild( row ) )
            } )

            tbody.appendChild( fragment )
            showResultsTable()
            updateVisibleMarkers() // Initial map update
        }

        /**
         * Filters the visible list items and updates the map markers based on a search term.
         */
        function filterListAndMap ( searchTerm ) {
            currentSearchTerm = searchTerm.toLowerCase()
            const tbody = document.getElementById( 'chargers-tbody' )
            if ( !tbody ) return

            const rows = tbody.querySelectorAll( 'tr[data-charger-id]' )
            let visibleIDs = []

            if ( !currentSearchTerm ) {
                // If search is cleared, show everything
                filteredChargerIDs = null
                tbody.querySelectorAll( 'tr' ).forEach( tr => {
                    tr.style.display = ''
                    const links = tr.querySelectorAll( '.restaurant-link' )
                    links.forEach( link => {
                        link.innerHTML = link.textContent // Remove highlight
                    } )
                } )
            } else {
                // Filter the list
                rows.forEach( mainRow => {
                    const chargerId = mainRow.dataset.chargerId
                    const restaurantRows = tbody.querySelectorAll( `tr[data-parent-id="${ chargerId }"], tr[data-charger-id="${ chargerId }"]` )
                    let hasMatch = false

                    restaurantRows.forEach( row => {
                        const link = row.querySelector( '.restaurant-link' )
                        if ( link ) {
                            const restaurantName = link.textContent
                            if ( restaurantName.toLowerCase().includes( currentSearchTerm ) ) {
                                hasMatch = true
                                const highlighted = restaurantName.replace(
                                    new RegExp( `(${ searchTerm })`, 'gi' ),
                                    '<mark>$1</mark>'
                                )
                                link.innerHTML = highlighted
                            } else {
                                link.innerHTML = restaurantName // Remove highlight
                            }
                        }
                    } )

                    if ( hasMatch ) {
                        visibleIDs.push( chargerId )
                        restaurantRows.forEach( row => row.style.display = '' )
                    } else {
                        restaurantRows.forEach( row => row.style.display = 'none' )
                    }
                } )
                filteredChargerIDs = visibleIDs
            }

            updateVisibleMarkers() // Trigger map update with new filter state
        }


        // --- MAP AND MARKER FUNCTIONS ---

        /**
         * The single source of truth for showing/hiding markers on the map.
         * It checks the map bounds and the current filter state.
         */
        function updateVisibleMarkers () {
            const bounds = map.getBounds()
            const zoom = map.getZoom()

            stationData.forEach( station => {
                const chargerShouldBeVisible = filteredChargerIDs === null || filteredChargerIDs.includes( station.id )
                const chargerMarker = station.chargerMarker

                // Update charger marker
                if ( chargerShouldBeVisible && bounds.contains( chargerMarker.getLatLng() ) ) {
                    if ( !chargerLayer.hasLayer( chargerMarker ) ) chargerLayer.addLayer( chargerMarker )
                } else {
                    if ( chargerLayer.hasLayer( chargerMarker ) ) chargerLayer.removeLayer( chargerMarker )
                }

                // Update restaurant markers (only if charger is visible and zoomed in)
                const restaurantsShouldBeVisible = chargerShouldBeVisible && zoom >= 14
                station.restaurantMarkers.forEach( restaurantMarker => {
                    const nameMatches = !currentSearchTerm || restaurantMarker.options.restaurantName.toLowerCase().includes( currentSearchTerm )
                    if ( restaurantsShouldBeVisible && nameMatches && bounds.contains( restaurantMarker.getLatLng() ) ) {
                        if ( !restaurantLayer.hasLayer( restaurantMarker ) ) restaurantLayer.addLayer( restaurantMarker )
                    } else {
                        if ( restaurantLayer.hasLayer( restaurantMarker ) ) restaurantLayer.removeLayer( restaurantMarker )
                    }
                } )
            } )
        }

        function createChargerMarker ( charger, restaurants, originCoords ) {
            let distanceFromOrigin = 'N/A'
            if ( originCoords ) {
                distanceFromOrigin = distance( originCoords[ 1 ], originCoords[ 0 ], charger.gps.latitude, charger.gps.longitude ).toFixed( 1 ) + ' mi'
            }

            let popupContent = `
                <div class="font-sans max-w-xs">
                    <strong class="text-lg">${ charger.name }</strong><br>
                    <strong>Stalls:</strong> ${ charger.stallCount }<br>
                    <strong>Distance:</strong> ${ distanceFromOrigin }<br>
                    <a href="https://maps.google.com/?q=${ charger.gps.latitude },${ charger.gps.longitude }" target="_blank" class="text-pink-500 hover:underline text-sm">Open in Google Maps</a>
                `

            if ( restaurants.length > 0 ) {
                popupContent += '<br><br><strong>Nearby Restaurants:</strong><br>'
                popupContent += restaurants.slice( 0, 5 ).map( r => `<div class="text-sm mt-1">â€¢ ${ r.name } (${ r.distance }m)</div>` ).join( '' )
                if ( restaurants.length > 5 ) popupContent += `<div class="text-sm mt-1 text-pink-600">and ${ restaurants.length - 5 } more...</div>`
            }
            popupContent += '</div>'

            return L.marker( [ charger.gps.latitude, charger.gps.longitude ], {
                icon: L.divIcon( {
                    className: 'emoji-icon',
                    html: 'âš¡ï¸',
                    iconSize: [ 24, 24 ],
                } )
            } ).bindPopup( popupContent )
        }

        function createRestaurantMarkers ( restaurants ) {
            return restaurants.map( restaurant => {
                return L.marker( [ restaurant.gps.latitude, restaurant.gps.longitude ], {
                    icon: L.divIcon( {
                        className: 'emoji-icon',
                        html: 'ðŸŒ­',
                        iconSize: [ 24, 24 ],
                    } ),
                    restaurantName: restaurant.name // Store for filtering
                } ).bindPopup( `<strong>${ restaurant.name }</strong><br>${ restaurant.distance }m away` )
            } )
        }

        function drawRoute ( coords ) {
            L.polyline( coords, {
                color: 'hotpink',
                weight: 5,
                opacity: 0.7
            } ).addTo( routeLayer )
        }

        // --- UI AND DOM MANIPULATION ---

        function createTableRowsForStation ( charger, restaurants, originCoords ) {
            const rows = []
            let distanceFromOrigin = 'N/A'
            if ( originCoords ) {
                distanceFromOrigin = distance( originCoords[ 1 ], originCoords[ 0 ], charger.gps.latitude, charger.gps.longitude ).toFixed( 1 ) + ' mi'
            }
            const address = [ charger.address.street, charger.address.city, charger.address.state ].filter( Boolean ).join( ', ' )

            const createRow = ( content, isMain = false ) => {
                const row = document.createElement( 'tr' )
                if ( isMain ) {
                    row.dataset.chargerId = charger.id.toString()
                    row.innerHTML = `
                        <td class="px-1 py-0 text-sm text-pink-500 border-r border-pink-200" rowspan="${ Math.max( 1, restaurants.length ) }">
                            <div class="flex flex-col">
                                <span>${ distanceFromOrigin }</span>
                                <span class="text-xs text-pink-600 hover:text-pink-800 cursor-pointer city-link">${ address || charger.name }</span>
                            </div>
                        </td>
                        ${ content }`
                } else {
                    row.dataset.parentId = charger.id.toString()
                    row.innerHTML = content
                }
                return row
            }

            if ( restaurants.length === 0 ) {
                rows.push( createRow( `<td class="px-1 py-0 text-sm text-pink-700">No restaurants found</td>`, true ) )
            } else {
                restaurants.forEach( ( restaurant, index ) => {
                    const content = `
                        <td class="px-1 py-0 text-sm text-pink-700">
                            <span class="text-pink-600 hover:text-pink-800 cursor-pointer restaurant-link">${ restaurant.name }</span> (${ restaurant.distance }m)
                        </td>`
                    rows.push( createRow( content, index === 0 ) )
                } )
            }
            // Add click handlers after creating the rows
            addClickHandlersToRows( rows, charger )
            return rows
        }

        function addClickHandlersToRows ( rows, charger ) {
            rows.forEach( row => {
                row.querySelector( '.city-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const station = stationData.find( s => s.id === charger.id.toString() )
                    if ( station ) {
                        map.setView( station.chargerMarker.getLatLng(), 15 )
                        station.chargerMarker.openPopup()
                        bottomResults.style.display = 'none'
                        document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                    }
                } )

                row.querySelector( '.restaurant-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const restaurantName = e.target.textContent
                    const station = stationData.find( s => s.id === charger.id.toString() )
                    if ( station ) {
                        const restaurantMarker = station.restaurantMarkers.find( m => m.options.restaurantName === restaurantName )
                        if ( restaurantMarker ) {
                            map.setView( restaurantMarker.getLatLng(), 16 )
                            restaurantMarker.openPopup()
                            bottomResults.style.display = 'none'
                            document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                        }
                    }
                } )
            } )
        }

        function clearPreviousResults () {
            routeLayer.clearLayers()
            chargerLayer.clearLayers()
            restaurantLayer.clearLayers()
            stationData = []
            filteredChargerIDs = null
            currentSearchTerm = ''
            restaurantSearchInput.value = ''
            document.getElementById( 'chargers-tbody' ).innerHTML = ''
        }

        function showLoadingState ( message ) {
            document.getElementById( 'loading-container' ).classList.remove( 'hidden' )
            document.getElementById( 'loading-text' ).textContent = message
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
            searchForm.style.display = 'none'
            bottomResults.style.display = 'block'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'
        }

        function showResultsTable () {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.remove( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
        }

        function showEmptyState ( message ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            const noResults = document.getElementById( 'no-results' )
            noResults.textContent = message
            noResults.classList.remove( 'hidden' )
        }

        function showErrorState ( message ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            updateStatus( message, true )
            // Optionally, revert to the search form
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
        }


        // --- API & GEOMETRY FUNCTIONS (largely unchanged) ---

        async function geocodeAddress ( address ) {
            const coordMatch = address.match( /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/ )
            if ( coordMatch ) {
                const lat = parseFloat( coordMatch[ 1 ] )
                const lon = parseFloat( coordMatch[ 2 ] )
                if ( lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180 ) return [ lon, lat ]
            }
            const url = `https://api.openrouteservice.org/geocode/search?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( address ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( `Geocoding failed: ${ response.statusText }` )
            const data = await response.json()
            if ( data.features && data.features.length > 0 ) return data.features[ 0 ].geometry.coordinates
            return null
        }

        async function getRoute ( startCoords, endCoords ) {
            const url = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson'
            const body = JSON.stringify( {
                "coordinates": [ startCoords, endCoords ],
                "radiuses": [ 5000, 5000 ]
            } )
            const response = await fetch( url, {
                method: 'POST',
                headers: {
                    'Authorization': ORS_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: body
            } )
            if ( !response.ok ) {
                const errorData = await response.json()
                throw new Error( errorData.error?.message || `Routing failed: ${ response.statusText }` )
            }
            const data = await response.json()
            return data.features[ 0 ]
        }

        async function getSuperchargers ( routeCoords ) {
            let minLat = Infinity,
                maxLat = -Infinity,
                minLon = Infinity,
                maxLon = -Infinity
            routeCoords.forEach( coord => {
                minLat = Math.min( minLat, coord[ 0 ] )
                maxLat = Math.max( maxLat, coord[ 0 ] )
                minLon = Math.min( minLon, coord[ 1 ] )
                maxLon = Math.max( maxLon, coord[ 1 ] )
            } )
            const padding = 0.5 // ~55km
            const query = `
                [out:json][timeout:30];
                (
                    node["amenity"="charging_station"]["operator"~"Tesla"](${ minLat - padding },${ minLon - padding },${ maxLat + padding },${ maxLon + padding });
                );
                out center;`
            const url = `https://overpass-api.de/api/interpreter?data=${ encodeURIComponent( query ) }`
            const response = await fetch( url )
            if ( !response.ok ) throw new Error( "Failed to fetch Supercharger data." )
            const data = await response.json()
            return data.elements.map( el => ( {
                id: el.id,
                name: el.tags?.name || `Tesla Supercharger ${ el.id }`,
                address: {
                    street: el.tags?.[ 'addr:street' ] || '',
                    city: el.tags?.[ 'addr:city' ] || '',
                    state: el.tags?.[ 'addr:state' ] || ''
                },
                gps: {
                    latitude: el.lat || el.center?.lat,
                    longitude: el.lon || el.center?.lon
                },
                stallCount: parseInt( el.tags?.capacity ) || 'N/A'
            } ) )
        }

        function findChargersNearRoute ( allChargers, routeCoords, radiusMiles ) {
            return allChargers.filter( charger => {
                if ( !charger.gps ) return false
                const chargerPoint = { lat: charger.gps.latitude, lng: charger.gps.longitude }
                for ( let i = 0; i < routeCoords.length - 1; i++ ) {
                    const segmentStart = { lat: routeCoords[ i ][ 0 ], lng: routeCoords[ i ][ 1 ] }
                    const segmentEnd = { lat: routeCoords[ i + 1 ][ 0 ], lng: routeCoords[ i + 1 ][ 1 ] }
                    if ( pointToLineSegmentDistance( chargerPoint, segmentStart, segmentEnd ) <= radiusMiles ) {
                        return true
                    }
                }
                return false
            } )
        }

        async function getNearbyRestaurantsBulk ( locations, radius = 500 ) {
            if ( locations.length === 0 ) return []
            const results = locations.map( () => ( { restaurants: [] } ) )
            const queryParts = locations.map( loc => `node[amenity~"restaurant|fast_food|cafe|bar|pub|food_court|ice_cream|bakery"](around:${ radius },${ loc.latitude },${ loc.longitude });` )
            const query = `[out:json][timeout:30];(${ queryParts.join( '' ) });out;`
            try {
                const response = await fetch( 'https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: `data=${ encodeURIComponent( query ) }`
                } )
                if ( !response.ok ) throw new Error( "Failed to fetch restaurant data." )
                const data = await response.json()
                data.elements.forEach( element => {
                    let closestIndex = -1, closestDistance = Infinity
                    locations.forEach( ( loc, index ) => {
                        const d = getDistance( loc.latitude, loc.longitude, element.lat, element.lon )
                        if ( d < closestDistance ) {
                            closestDistance = d
                            closestIndex = index
                        }
                    } )
                    if ( closestIndex !== -1 && closestDistance <= radius ) {
                        results[ closestIndex ].restaurants.push( {
                            id: element.id,
                            name: element.tags?.name || `Restaurant ${ element.id }`,
                            gps: { latitude: element.lat, longitude: element.lon },
                            distance: closestDistance
                        } )
                    }
                } )
                results.forEach( r => r.restaurants.sort( ( a, b ) => a.distance - b.distance ) )
                return results
            } catch ( error ) {
                console.warn( "Could not fetch restaurant data:", error )
                return results // Return empty restaurant arrays on failure
            }
        }

        function distance ( lat1, lon1, lat2, lon2 ) {
            const R = 3958.8 // Miles
            const dLat = ( lat2 - lat1 ) * Math.PI / 180
            const dLon = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( dLat / 2 ) * Math.sin( dLat / 2 ) + Math.cos( lat1 * Math.PI / 180 ) * Math.cos( lat2 * Math.PI / 180 ) * Math.sin( dLon / 2 ) * Math.sin( dLon / 2 )
            return R * ( 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) ) )
        }

        function getDistance ( lat1, lon1, lat2, lon2 ) {
            const R = 6371e3 // Metres
            const Ï†1 = lat1 * Math.PI / 180
            const Ï†2 = lat2 * Math.PI / 180
            const Î”Ï† = ( lat2 - lat1 ) * Math.PI / 180
            const Î”Î» = ( lon2 - lon1 ) * Math.PI / 180
            const a = Math.sin( Î”Ï† / 2 ) * Math.sin( Î”Ï† / 2 ) + Math.cos( Ï†1 ) * Math.cos( Ï†2 ) * Math.sin( Î”Î» / 2 ) * Math.sin( Î”Î» / 2 )
            return Math.round( R * ( 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) ) ) )
        }

        function pointToLineSegmentDistance ( p, a, b ) {
            const l2 = ( a.lat - b.lat ) ** 2 + ( a.lng - b.lng ) ** 2
            if ( l2 === 0 ) return distance( p.lat, p.lng, a.lat, a.lng )
            let t = ( ( p.lat - a.lat ) * ( b.lat - a.lat ) + ( p.lng - a.lng ) * ( b.lng - a.lng ) ) / l2
            t = Math.max( 0, Math.min( 1, t ) )
            const projection = {
                lat: a.lat + t * ( b.lat - a.lat ),
                lng: a.lng + t * ( b.lng - a.lng )
            }
            return distance( p.lat, p.lng, projection.lat, projection.lng )
        }

        // --- UNCHANGED HELPER FUNCTIONS (Autocomplete, Location, Modals, etc.) ---

        async function handleLocationClick () {
            locationText.textContent = 'Getting location...'
            loadingSpinner.classList.remove( 'hidden' )
            locationBtn.disabled = true
            try {
                const position = await new Promise( ( resolve, reject ) => navigator.geolocation.getCurrentPosition( resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 10000
                } ) )
                const { latitude: lat, longitude: lon } = position.coords
                const address = await reverseGeocode( lat, lon )
                originInput.value = address || `${ lat.toFixed( 4 ) }, ${ lon.toFixed( 4 ) }`
                updateStatus( "Location detected and set as origin.", false )
            } catch ( error ) {
                console.log( "Geolocation error:", error )
                updateStatus( "Could not access your location.", true )
            } finally {
                locationText.textContent = 'ðŸ‘‘ Use Current Location'
                loadingSpinner.classList.add( 'hidden' )
                locationBtn.disabled = false
            }
        }

        async function reverseGeocode ( lat, lon ) {
            const url = `https://api.openrouteservice.org/geocode/reverse?api_key=${ ORS_API_KEY }&point.lon=${ lon }&point.lat=${ lat }&size=1`
            const response = await fetch( url )
            if ( !response.ok ) return null
            const data = await response.json()
            return data.features?.[ 0 ]?.properties?.label || null
        }

        let debounceTimer
        function setupAutocomplete ( inputElement, suggestionsDiv ) {
            inputElement.addEventListener( 'input', () => {
                clearTimeout( debounceTimer )
                debounceTimer = setTimeout( async () => {
                    const query = inputElement.value
                    if ( query.length < 3 ) {
                        suggestionsDiv.classList.add( 'hidden' )
                        return
                    }
                    try {
                        const url = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ ORS_API_KEY }&text=${ encodeURIComponent( query ) }&size=5`
                        const response = await fetch( url )
                        if ( !response.ok ) throw new Error( 'Autocomplete failed' )
                        const data = await response.json()
                        displaySuggestions( data.features, suggestionsDiv, inputElement )
                    } catch ( error ) {
                        console.error( 'Autocomplete error:', error )
                        suggestionsDiv.classList.add( 'hidden' )
                    }
                }, 300 )
            } )
            inputElement.addEventListener( 'blur', () => setTimeout( () => suggestionsDiv.classList.add( 'hidden' ), 150 ) )
        }

        function displaySuggestions ( features, suggestionsDiv, input ) {
            suggestionsDiv.innerHTML = ''
            if ( !features || features.length === 0 ) {
                suggestionsDiv.classList.add( 'hidden' )
                return
            }
            features.forEach( feature => {
                const suggestion = document.createElement( 'div' )
                suggestion.className = 'autocomplete-suggestion'
                suggestion.textContent = feature.properties.label
                suggestion.addEventListener( 'click', () => {
                    input.value = feature.properties.label
                    suggestionsDiv.classList.add( 'hidden' )
                } )
                suggestionsDiv.appendChild( suggestion )
            } )
            const inputRect = input.getBoundingClientRect()
            suggestionsDiv.style.left = `${ inputRect.left }px`
            suggestionsDiv.style.top = `${ inputRect.bottom + window.scrollY }px`
            suggestionsDiv.style.width = `${ inputRect.width }px`
            suggestionsDiv.classList.remove( 'hidden' )
        }

        setupAutocomplete( originInput, originSuggestions )
        setupAutocomplete( destinationInput, destinationSuggestions )

        document.getElementById( 'toggle-btn' ).addEventListener( 'click', () => {
            const isHidden = bottomResults.style.display === 'none'
            bottomResults.style.display = isHidden ? 'block' : 'none'
            document.getElementById( 'toggle-btn' ).textContent = isHidden ? 'Show map' : 'Show Results'
            setTimeout( () => map.invalidateSize(), 100 )
        } )

        newSearchBtn.addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.remove( 'hidden' ) )
        document.getElementById( 'cancel-new-search' ).addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.add( 'hidden' ) )
        document.getElementById( 'confirm-new-search' ).addEventListener( 'click', () => window.location.href = window.location.pathname )

        function updateStatus ( message, isError = false ) {
            statusMessage.textContent = message
            statusMessage.className = `text-center mt-3 text-sm font-medium ${ isError ? 'text-red-600' : 'text-pink-600' }`
        }

        function updateUrlForSearch ( origin, destination ) {
            const url = new URL( window.location )
            url.searchParams.set( 'origin', encodeURIComponent( origin ) )
            url.searchParams.set( 'destination', encodeURIComponent( destination ) )
            window.history.pushState( {}, '', url )
        }

    </script>

</body>

</html>