<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passenger Princess Protector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        .font-dancing {
            font-family: 'Dancing Script', cursive;
        }

        /* Full screen map */
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: calc(100vh - 60px);
            width: 100vw;
            position: absolute;
            top: 60px;
            margin: 0;
            padding: 0;
        }

        /* Overlay form at top */
        .overlay-form {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Results area */
        .bottom-results {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 1100;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
            height: calc(100vh - 60px);
        }

        /* Compact table styling */
        #chargers-table {
            border-collapse: collapse;
            line-height: 1;
            height: auto;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            width: 100%;
        }

        #chargers-table tr,
        #chargers-table tr td,
        #chargers-table tr th {
            height: 18px !important;
            line-height: 1 !important;
        }

        #chargers-table td,
        #chargers-table th {
            border-bottom: 1px solid #fbcfe8;
            /* pink-200 */
        }

        /* Custom scrollbar for the results list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Table styles */
        #chargers-table {
            table-layout: fixed;
            width: 100%;
        }

        #chargers-table td {
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .overlay-form {
                padding: 10px;
                position: fixed;
                top: 0;
            }

            .bottom-results {
                padding: 0;
            }

            /* Table responsive design */
            #chargers-table {
                font-size: 10px;
                min-width: 600px;
            }

            #chargers-table th,
            #chargers-table td {
                padding: 4px 6px;
            }
        }

        .autocomplete-suggestions {
            position: fixed;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1100;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 2px;
        }

        .autocomplete-suggestion {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.15s ease-in-out;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestion:hover {
            background: #f8fafc;
        }

        /* Enhanced link styling for clickable results */
        .city-link,
        .restaurant-link {
            text-decoration: underline;
            text-decoration-color: rgba(236, 72, 153, 0.5);
            text-underline-offset: 2px;
        }

        .city-link:hover,
        .restaurant-link:hover {
            text-decoration-color: rgb(236, 72, 153);
        }

        /* Custom emoji icons for map markers */
        .emoji-icon {
            font-size: 24px;
            line-height: 1;
            text-align: center;
            /* Simple shadow for better visibility */
            text-shadow: 0 0 3px white, 0 0 5px white;
        }

        /* Search highlight styling */
        mark {
            background-color: rgba(254, 243, 199, 0.6) !important;
            color: inherit !important;
            padding: 0 1px !important;
            border-radius: 2px !important;
            font-weight: inherit !important;
            box-shadow: 0 0 0 1px rgba(254, 243, 199, 0.3) !important;
        }

        /* Loading spinner styles */
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #ec4899;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #cuisine-filter-buttons button.selected {
            background-color: #ec4899;
            /* pink-500 */
            color: white;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }

        /* Princess marker styling */
        .princess-marker {
            background: transparent !important;
            border: none !important;
            font-size: 36px !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body class="bg-pink-100 font-sans antialiased">
    <div id="map"></div>

    <div id="top-toolbar"
        class="fixed top-0 left-0 right-0 z-50 bg-gradient-to-r from-pink-200 to-pink-300 border-b border-pink-400 p-3 flex justify-between items-center shadow-lg">
        <div class="text-2xl font-bold text-pink-800 font-dancing">PPP</div>
        <div class="flex space-x-2">
            <button id="gps-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-3 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200 hidden"
                title="Center on Princess">üìç</button>
            <button id="toggle-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200">Show
                Results</button>
            <button id="new-search-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200">New
                Search</button>
        </div>
    </div>

    <div class="bottom-results" id="bottom-results">
        <div id="results-list" class="custom-scrollbar px-2" style="height: 100%; overflow-y: auto;">
            <div class="flex space-x-2 mb-4 pt-4">
                <input type="text" id="restaurant-search"
                    class="flex-grow px-4 py-3 border border-pink-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-pink-500 text-sm enhanced-input"
                    placeholder="Search restaurants or cuisines...">
                <button id="toggle-cuisine-btn"
                    class="px-3 py-3 bg-pink-400 hover:bg-pink-500 text-white rounded-md shadow-sm text-sm"
                    title="Toggle cuisine filters">Filters</button>
            </div>
            <div id="cuisine-filter-buttons" class="flex flex-wrap gap-2 mb-4" style="display: none;">
            </div>

            <div id="loading-container" class="loading-container hidden">
                <div class="spinner"></div>
                <p class="loading-text" id="loading-text">Planning your royal journey...</p>
            </div>

            <div style="overflow-x: auto;">
                <table id="chargers-table" class="hidden">
                    <thead class="sticky top-0 bg-white z-10">
                        <tr>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-20">
                                Charger
                            </th>
                            <th class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider">
                                Restaurant
                            </th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-16">
                                Walk
                            </th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-24">
                                Cuisine
                            </th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-20">
                                Status
                            </th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-16">
                                Rating
                            </th>
                        </tr>
                    </thead>
                    <tbody id="chargers-tbody">
                    </tbody>
                </table>
            </div>
            <p id="no-results" class="text-pink-500">Search for a route to see results.</p>
        </div>
        <hr class="border-pink-300">
    </div>

    <div class="overlay-form" id="search-form">
        <header class="text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold text-pink-800 font-dancing">Passenger Princess Protector</h1>
        </header>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-end">
            <div class="relative">
                <div class="flex items-center justify-between mb-1">
                    <label for="origin" class="block text-sm font-medium text-pink-700">Origin</label>
                    <button id="location-btn"
                        class="bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white px-3 py-1 rounded-md text-xs font-medium focus:outline-none disabled:opacity-50 whitespace-nowrap shadow-md hover:shadow-lg transition-all duration-200">
                        <span id="location-text">üë∏ Use Current Location</span>
                        <div id="loading-spinner"
                            class="hidden w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin inline-block ml-2">
                        </div>
                    </button>
                </div>
                <input type="text" id="origin"
                    class="block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm enhanced-input"
                    placeholder="e.g., San Francisco, CA">
                <div id="origin-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="relative">
                <label for="destination" class="block text-sm font-medium text-pink-700">Destination</label>
                <input type="text" id="destination"
                    class="mt-1 block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm enhanced-input"
                    placeholder="e.g., Los Angeles, CA">
                <div id="destination-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>
            <div class="md:col-span-2">
                <button id="find-route-btn"
                    class="w-full bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all duration-200 text-sm hover:shadow-lg">
                    Plan Supercharged Dinner
                </button>
            </div>
        </div>
        <div id="status-message" class="text-center mt-3 text-pink-600 font-medium text-sm"></div>
    </div>

    <div id="new-search-modal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[1200] hidden">
        <div class="bg-white rounded-lg p-6 max-w-sm mx-4 shadow-xl">
            <h3 class="text-lg font-semibold text-pink-800 mb-4 font-dancing">Are you sure?</h3>
            <p class="text-gray-600 mb-6">This will clear your current search and start a new one.</p>
            <div class="flex space-x-3 justify-end">
                <button id="cancel-new-search"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium">Cancel</button>
                <button id="confirm-new-search"
                    class="px-4 py-2 bg-pink-500 hover:bg-pink-600 text-white rounded-lg font-medium">Yes, New
                    Search</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const originInput = document.getElementById( 'origin' )
        const destinationInput = document.getElementById( 'destination' )
        const findRouteBtn = document.getElementById( 'find-route-btn' )
        const statusMessage = document.getElementById( 'status-message' )
        const mapElement = document.getElementById( 'map' )
        const originSuggestions = document.getElementById( 'origin-suggestions' )
        const destinationSuggestions = document.getElementById( 'destination-suggestions' )
        const searchForm = document.getElementById( 'search-form' )
        const bottomResults = document.getElementById( 'bottom-results' )
        const topToolbar = document.getElementById( 'top-toolbar' )
        const newSearchBtn = document.getElementById( 'new-search-btn' )
        const locationBtn = document.getElementById( 'location-btn' )
        const locationText = document.getElementById( 'location-text' )
        const loadingSpinner = document.getElementById( 'loading-spinner' )
        const restaurantSearchInput = document.getElementById( 'restaurant-search' )
        const cuisineFilterButtons = document.getElementById( 'cuisine-filter-buttons' )

        // Initially hide the top toolbar and adjust map position since search form is visible
        topToolbar.style.display = 'none'
        mapElement.style.top = '0'
        mapElement.style.height = '100vh'

        // --- MAP INITIALIZATION ---
        let map = L.map( mapElement, {
            zoomControl: false,
            zoomSnap: 0.5,
            zoomDelta: 1
        } ).setView( [ 37.7749, -122.4194 ], 6 ) // Default to SF
        L.tileLayer( 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        } ).addTo( map )

        // Map Layers
        const routeLayer = L.layerGroup().addTo( map )
        const chargerLayer = L.layerGroup().addTo( map )
        const restaurantLayer = L.layerGroup().addTo( map )
        const userLocationLayer = L.layerGroup().addTo( map )
        const viewportSuperchargersLayer = L.layerGroup().addTo( map )

        // --- STATE MANAGEMENT ---
        let userLocationMarker = null
        let locationTrackingInterval = null
        let stationData = [] // Single source of truth for all station data
        let filteredChargerIDs = null
        let currentSearchTerm = ''
        let currentCuisineFilter = []
        let viewportSuperchargers = new Map() // Map of place_id to supercharger data
        let lastViewportBounds = null // Track last viewport bounds to avoid unnecessary API calls

        // Autocomplete session tokens for each input field
        let autocompleteSessions = {
            origin: null,
            destination: null
        }

        // --- EVENT LISTENERS ---
        findRouteBtn.addEventListener( 'click', handleRouteSearch )
        locationBtn.addEventListener( 'click', handleLocationClick )
        restaurantSearchInput.addEventListener( 'input', () => {
            filterListAndMap( restaurantSearchInput.value, currentCuisineFilter )
        } )

        cuisineFilterButtons.addEventListener( 'click', ( e ) => {
            if ( e.target.tagName !== 'BUTTON' ) return
            const cuisine = e.target.dataset.cuisine
            const isSelected = e.target.classList.toggle( 'selected' )

            // Update filter array based on selection
            if ( isSelected ) {
                if ( cuisine === '' ) { // "All Cuisines" selected
                    currentCuisineFilter = [ '' ]
                    Array.from( cuisineFilterButtons.children ).forEach( btn => {
                        if ( btn !== e.target ) btn.classList.remove( 'selected' )
                    } )
                } else {
                    currentCuisineFilter = currentCuisineFilter.filter( c => c !== '' ) // Remove "All" if present
                    currentCuisineFilter.push( cuisine )
                    cuisineFilterButtons.querySelector( 'button[data-cuisine=""]' )?.classList.remove( 'selected' )
                }
            } else {
                currentCuisineFilter = currentCuisineFilter.filter( c => c !== cuisine )
            }

            // If nothing is selected, default back to "All Cuisines"
            if ( currentCuisineFilter.length === 0 ) {
                currentCuisineFilter = [ '' ]
                cuisineFilterButtons.querySelector( 'button[data-cuisine=""]' )?.classList.add( 'selected' )
            }

            filterListAndMap( currentSearchTerm, currentCuisineFilter )
        } )

        map.on( 'moveend zoomend', updateVisibleMarkers )

        // Initial call to load viewport superchargers
        updateVisibleMarkers();

        // --- AUTO-SEARCH FROM URL PARAMS ---
        ( function autoSearchFromUrl () {
            const urlParams = new URLSearchParams( window.location.search )
            const originParam = urlParams.get( 'origin' )
            const destinationParam = urlParams.get( 'destination' )
            if ( originParam && destinationParam ) {
                originInput.value = decodeURIComponent( originParam )
                destinationInput.value = decodeURIComponent( destinationParam )
                setTimeout( () => handleRouteSearch(), 500 )
            }
        } )()

        // --- CORE APPLICATION LOGIC ---

        /**
         * Main function to handle the entire search process.
         */
        async function handleRouteSearch () {
            const origin = originInput.value.trim()
            const destination = destinationInput.value.trim()

            if ( !origin || !destination ) {
                updateStatus( "Please enter both an origin and a destination.", true )
                return
            }

            updateUrlForSearch( origin, destination )
            clearPreviousResults()
            showLoadingState( "Planning your royal journey..." )

            try {
                const response = await fetch( `/route?origin=${ encodeURIComponent( origin ) }&destination=${ encodeURIComponent( destination ) }` )
                const data = await response.json()

                if ( !response.ok ) {
                    throw new Error( data.error || "An unknown error occurred." )
                }

                processAndDisplayResults( data )
                updateStatus( `Found ${ data.superchargers.length } Superchargers with restaurants.`, false )

            } catch ( error ) {
                console.error( "Error during route search:", error )
                // The error from the server is now in error.message
                const userMessage = error.message.includes( "Could not find a route" ) ?
                    "Could not find a route. Please try a different or more specific location." :
                    error.message // Directly use the message from the server
                showErrorState( `Oops! ${ userMessage }` )
            }
        }

        /**
         * Takes the full API response, processes it, and builds the UI.
         */
        function processAndDisplayResults ( data ) {
            // Draw route on map using the traffic segments built from intervals
            const trafficSegments = data.route && data.route.travelAdvisory && data.route.travelAdvisory.speedReadingIntervals
                ? buildTrafficSegments( data.route.EncodedPolyline, data.route.travelAdvisory.speedReadingIntervals )
                : []
            drawTrafficSegments( trafficSegments )

            // Draw search circles
            if ( data.search_circles ) {
                data.search_circles.forEach( circle => {
                    L.circle( [ circle.center.latitude, circle.center.longitude ], {
                        color: 'blue',
                        fillColor: 'blue',
                        fillOpacity: 0.1,
                        radius: circle.radius
                    } ).addTo( routeLayer )
                } )
            }            // Set map bounds using the main route polyline
            const routeCoords = decodePolyline( data.route.EncodedPolyline )
            if ( routeCoords.length > 0 ) {
                map.fitBounds( L.polyline( routeCoords ).getBounds().pad( 0.1 ) )
            }

            if ( data.superchargers.length === 0 ) {
                showEmptyState( "No Superchargers found near your route." )
                return
            }

            // Reset state and build the new `stationData` and table UI
            stationData = []
            const tbody = document.getElementById( 'chargers-tbody' )
            tbody.innerHTML = ''
            const fragment = document.createDocumentFragment()

            data.superchargers.forEach( ( charger, index ) => {
                const chargerId = `charger-${ index }`
                const chargerMarker = createChargerMarker( charger, chargerId )
                const restaurantMarkers = createRestaurantMarkers( charger.supercharger.restaurants )

                stationData.push( {
                    id: chargerId,
                    chargerInfo: charger,
                    restaurants: charger.restaurants || [],
                    chargerMarker: chargerMarker,
                    restaurantMarkers: restaurantMarkers,
                } )

                const tableRows = createTableRowsForStation( charger, chargerId )
                tableRows.forEach( row => fragment.appendChild( row ) )
            } )

            tbody.appendChild( fragment )
            populateCuisineFilter()
            showResultsTable()
            updateVisibleMarkers() // Initial map update
        }

        /**
         * Filters the list and map based on search term and cuisine.
         */
        function filterListAndMap ( searchTerm, cuisines ) {
            currentSearchTerm = searchTerm.toLowerCase()
            currentCuisineFilter = Array.isArray( cuisines ) ? cuisines.map( c => c.toLowerCase() ) : ( cuisines ? [ cuisines.toLowerCase() ] : [] )

            const tbody = document.getElementById( 'chargers-tbody' )
            if ( !tbody ) return

            const rows = tbody.querySelectorAll( 'tr[data-charger-id]' )
            const chargerVisibility = new Map()

            // First pass: determine which chargers should be visible at all
            rows.forEach( row => {
                const chargerId = row.dataset.chargerId
                const restaurantCell = row.querySelector( '.restaurant-link' )
                const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )

                // Default to not visible unless a match is found
                if ( !chargerVisibility.has( chargerId ) ) {
                    chargerVisibility.set( chargerId, false )
                }

                const restaurantName = restaurantCell ? restaurantCell.dataset.originalName : ''
                const originalCuisines = cuisineCell ? cuisineCell.dataset.originalCuisine.toLowerCase().split( '; ' ).map( c => c.trim() ) : []

                const searchMatch = !currentSearchTerm || ( restaurantName && restaurantName.toLowerCase().includes( currentSearchTerm ) )
                const cuisineMatch = currentCuisineFilter.includes( '' ) || currentCuisineFilter.length === 0 || currentCuisineFilter.some( fc => originalCuisines.includes( fc ) )

                if ( searchMatch && cuisineMatch ) {
                    chargerVisibility.set( chargerId, true )
                }
            } )

            // Second pass: Show/hide rows and highlight text
            let visibleChargerIDs = new Set()
            rows.forEach( row => {
                const chargerId = row.dataset.chargerId
                const isChargerVisible = chargerVisibility.get( chargerId )
                row.style.display = isChargerVisible ? '' : 'none'

                if ( isChargerVisible ) {
                    visibleChargerIDs.add( chargerId )
                    highlightTextInRow( row, searchTerm, currentCuisineFilter )
                }
            } )

            filteredChargerIDs = ( currentSearchTerm || currentCuisineFilter.length > 0 && !currentCuisineFilter.includes( '' ) ) ? Array.from( visibleChargerIDs ) : null
            updateVisibleMarkers()
        }

        // --- MAP AND MARKER FUNCTIONS ---

        /**
         * Builds traffic segments from the main polyline and speed reading intervals.
         */
        function buildTrafficSegments ( encodedPolyline, intervals ) {
            const allCoords = decodePolyline( encodedPolyline )
            const segments = []

            intervals.forEach( interval => {
                const start = interval.startPolylinePointIndex
                const end = interval.endPolylinePointIndex
                const coords = allCoords.slice( start, end + 1 )
                if ( coords.length > 1 ) {
                    const polyline = encodePolyline( coords ) // Need to encode back for the segment
                    segments.push( {
                        polyline: polyline,
                        speed: interval.speed
                    } )
                }
            } )

            return segments
        }

        /**
         * Encodes an array of coordinates back to Google polyline format.
         */
        function encodePolyline ( coords ) {
            let result = ''
            let prevLat = 0
            let prevLng = 0

            coords.forEach( coord => {
                const lat = Math.round( coord[ 0 ] * 1e5 )
                const lng = Math.round( coord[ 1 ] * 1e5 )

                const dLat = lat - prevLat
                const dLng = lng - prevLng

                result += encodeNumber( dLat )
                result += encodeNumber( dLng )

                prevLat = lat
                prevLng = lng
            } )

            return result
        }

        function encodeNumber ( num ) {
            let result = ''
            let shifted = num << 1
            if ( num < 0 ) shifted = ~shifted
            while ( shifted >= 0x20 ) {
                result += String.fromCharCode( ( 0x20 | ( shifted & 0x1f ) ) + 63 )
                shifted >>= 5
            }
            result += String.fromCharCode( shifted + 63 )
            return result
        }

        /**
         * Decodes a Google Maps encoded polyline string into an array of coordinates.
         */
        function decodePolyline ( encoded ) {
            const len = encoded.length
            const coords = []
            let index = 0
            let lat = 0
            let lng = 0

            while ( index < len ) {
                let b
                let shift = 0
                let result = 0
                do {
                    b = encoded.charCodeAt( index++ ) - 63
                    result |= ( b & 0x1f ) << shift
                    shift += 5
                } while ( b >= 0x20 )
                const dlat = ( ( result & 1 ) ? ~( result >> 1 ) : ( result >> 1 ) )
                lat += dlat

                shift = 0
                result = 0
                do {
                    b = encoded.charCodeAt( index++ ) - 63
                    result |= ( b & 0x1f ) << shift
                    shift += 5
                } while ( b >= 0x20 )
                const dlng = ( ( result & 1 ) ? ~( result >> 1 ) : ( result >> 1 ) )
                lng += dlng

                coords.push( [ lat / 1e5, lng / 1e5 ] )
            }

            return coords
        }

        /**
         * Draws the route on the map using traffic segment data.
         */
        function drawTrafficSegments ( trafficSegments ) {
            routeLayer.clearLayers()
            if ( !trafficSegments || trafficSegments.length === 0 ) {
                return
            }

            trafficSegments.forEach( segment => {
                const coords = decodePolyline( segment.polyline )
                if ( coords.length < 2 ) return

                let color
                switch ( segment.speed ) {
                    case 'NORMAL': color = '#34D399'; break // Emerald 400
                    case 'SLOW': color = '#FBBF24'; break // Amber 400
                    case 'TRAFFIC_JAM': color = '#F87171'; break // Red 400
                    default: color = '#60A5FA'; break // Blue 400
                }

                L.polyline( coords, {
                    color: color,
                    weight: 6,
                    opacity: 0.85
                } ).addTo( routeLayer )
            } )
        }

        function updateVisibleMarkers () {
            // This function remains largely the same
            const bounds = map.getBounds()
            const zoom = map.getZoom()

            stationData.forEach( station => {
                const chargerShouldBeVisible = filteredChargerIDs === null || filteredChargerIDs.includes( station.id )
                const chargerMarker = station.chargerMarker

                if ( chargerShouldBeVisible && bounds.contains( chargerMarker.getLatLng() ) ) {
                    if ( !chargerLayer.hasLayer( chargerMarker ) ) chargerLayer.addLayer( chargerMarker )
                } else {
                    if ( chargerLayer.hasLayer( chargerMarker ) ) chargerLayer.removeLayer( chargerMarker )
                }

                const restaurantsShouldBeVisible = chargerShouldBeVisible && zoom >= 14
                station.restaurantMarkers.forEach( restaurantMarker => {
                    const nameMatches = !currentSearchTerm || restaurantMarker.options.restaurantName.toLowerCase().includes( currentSearchTerm )
                    const restaurantCuisines = ( restaurantMarker.options.cuisine || '' ).toLowerCase().split( '; ' ).map( c => c.trim() )
                    const cuisineMatches = currentCuisineFilter.length === 0 || currentCuisineFilter.includes( '' ) || currentCuisineFilter.some( fc => fc !== '' && restaurantCuisines.includes( fc.toLowerCase() ) )

                    if ( restaurantsShouldBeVisible && nameMatches && cuisineMatches && bounds.contains( restaurantMarker.getLatLng() ) ) {
                        if ( !restaurantLayer.hasLayer( restaurantMarker ) ) restaurantLayer.addLayer( restaurantMarker )
                    } else {
                        if ( restaurantLayer.hasLayer( restaurantMarker ) ) restaurantLayer.removeLayer( restaurantMarker )
                    }
                } )
            } )

            // Update viewport superchargers
            updateViewportSuperchargers( bounds )
        }

        /**
         * Fetches and updates superchargers for the current viewport.
         */
        async function updateViewportSuperchargers ( bounds ) {
            const boundsStr = bounds.toBBoxString()
            if ( lastViewportBounds === boundsStr ) {
                return // No change in viewport
            }
            lastViewportBounds = boundsStr

            const [ minLng, minLat, maxLng, maxLat ] = boundsStr.split( ',' ).map( parseFloat )

            try {
                const response = await fetch( `/superchargers/viewport?min_lat=${ minLat }&max_lat=${ maxLat }&min_lng=${ minLng }&max_lng=${ maxLng }` )
                const data = await response.json()

                if ( !response.ok ) {
                    console.error( 'Failed to fetch viewport superchargers:', data )
                    return
                }

                const superchargers = data.superchargers

                // Create a set of current supercharger place_ids
                const currentPlaceIds = new Set( superchargers.map( sc => sc.place_id ) )

                // Remove superchargers that are no longer in viewport
                for ( const [ placeId, superchargerData ] of viewportSuperchargers ) {
                    if ( !currentPlaceIds.has( placeId ) ) {
                        viewportSuperchargersLayer.removeLayer( superchargerData.marker )
                        viewportSuperchargers.delete( placeId )
                    }
                }

                // Add new superchargers
                superchargers.forEach( supercharger => {
                    if ( !viewportSuperchargers.has( supercharger.place_id ) ) {
                        const marker = createViewportSuperchargerMarker( supercharger )
                        viewportSuperchargers.set( supercharger.place_id, {
                            data: supercharger,
                            marker: marker
                        } )
                        viewportSuperchargersLayer.addLayer( marker )
                    }
                } )

            } catch ( error ) {
                console.error( 'Error fetching viewport superchargers:', error )
            }
        }

        /**
         * Creates a marker for a viewport supercharger.
         */
        function createViewportSuperchargerMarker ( supercharger ) {
            const popupContent = `
                <div class="font-sans max-w-xs">
                    <strong class="text-lg">${ supercharger.name }</strong><br>
                    <strong>Address:</strong> ${ supercharger.address }<br>
                    <a href="https://maps.google.com/?q=${ supercharger.latitude },${ supercharger.longitude }" target="_blank" class="text-pink-500 hover:underline text-sm">Open in Google Maps</a>
                </div>
            `

            return L.marker( [ supercharger.latitude, supercharger.longitude ], {
                icon: L.divIcon( {
                    className: 'emoji-icon',
                    html: 'üîå',
                    iconSize: [ 24, 24 ],
                } )
            } ).bindPopup( popupContent )
        }

        function createChargerMarker ( charger, chargerId ) {
            // This function remains the same
            const distanceFromOrigin = charger.distance_from_route ? ( charger.distance_from_route / 1609.34 ).toFixed( 1 ) + ' mi' : 'N/A'
            const arrivalTime = charger.arrival_time || 'N/A'
            let popupContent = `
                <div class="font-sans max-w-xs">
                    <strong class="text-lg">${ charger.supercharger.name }</strong><br>
                    <strong>Address:</strong> ${ charger.supercharger.address }<br>
                    <strong>Arrival:</strong> ${ arrivalTime }<br>
                    <strong>Distance:</strong> ${ distanceFromOrigin }<br>
                    <button onclick="showChargerInResults('${ chargerId }')" class="bg-pink-500 hover:bg-pink-600 text-white text-sm px-2 py-1 rounded mt-2 mr-2">View in Results</button>
                    <a href="https://maps.google.com/?q=${ charger.supercharger.latitude },${ charger.supercharger.longitude }" target="_blank" class="text-pink-500 hover:underline text-sm">Open in Google Maps</a>
                `

            if ( charger.supercharger.restaurants && charger.supercharger.restaurants.length > 0 ) {
                popupContent += '<br><br><strong>Nearby Restaurants:</strong><br>'
                popupContent += charger.supercharger.restaurants.slice( 0, 5 ).map( r => `<div class="text-sm mt-1">‚Ä¢ ${ r.name } (${ r.walking_distance_meters }m)</div>` ).join( '' )
                if ( charger.supercharger.restaurants.length > 5 ) popupContent += `<div class="text-sm mt-1 text-black">and ${ charger.supercharger.restaurants.length - 5 } more...</div>`
            }
            popupContent += '</div>'

            return L.marker( [ charger.supercharger.latitude, charger.supercharger.longitude ], {
                icon: L.divIcon( {
                    className: 'emoji-icon',
                    html: 'üîã',
                    iconSize: [ 24, 24 ],
                } )
            } ).bindPopup( popupContent )
        }

        function createRestaurantMarkers ( restaurants ) {
            // This function remains the same
            return ( restaurants || [] ).map( restaurant => {
                return L.marker( [ restaurant.latitude, restaurant.longitude ], {
                    icon: L.divIcon( {
                        className: 'emoji-icon',
                        html: 'üå≠',
                        iconSize: [ 24, 24 ],
                    } ),
                    restaurantName: restaurant.name,
                    cuisine: ( restaurant.primary_type || '' )
                } ).bindPopup( `<strong>${ restaurant.name }</strong><br>${ restaurant.walking_distance_meters || 'Distance unknown' }` )
            } )
        }

        // --- UI AND DOM MANIPULATION ---

        function createTableRowsForStation ( charger, chargerId ) {
            // This function remains the same
            const rows = []
            const restaurants = charger.supercharger.restaurants || []
            const distanceFromOrigin = charger.distance_from_route ? ( charger.distance_from_route / 1609.34 ).toFixed( 1 ) + ' mi' : 'N/A'
            const arrivalTime = charger.arrival_time || 'N/A'

            const chargerCell = `
                <td class="px-1 py-0 text-sm text-pink-500 border-r border-pink-200" rowspan="${ Math.max( 1, restaurants.length ) }">
                    <div class="flex flex-col">
                        <span>${ distanceFromOrigin }</span>
                        <span class="font-bold">${ arrivalTime }</span>
                        <span class="text-xs text-pink-600 hover:text-pink-800 cursor-pointer city-link">${ charger.supercharger.address }</span>
                    </div>
                </td>
            `

            if ( restaurants.length === 0 ) {
                const row = document.createElement( 'tr' )
                row.dataset.chargerId = chargerId
                row.innerHTML = `
                    ${ chargerCell }
                    <td class="px-1 py-0 text-sm text-pink-700" colspan="5">No restaurants found</td>
                `
                rows.push( row )
            } else {
                restaurants.forEach( ( restaurant, index ) => {
                    const row = document.createElement( 'tr' )
                    row.dataset.chargerId = chargerId
                    row.dataset.restaurantId = restaurant.name // Use name as a simple ID

                    const cuisineStr = restaurant.primary_type || 'N/A'
                    const statusHtml = '<span class="text-gray-600">Status unknown</span>'

                    const restaurantContent = `
                        <td class="px-1 py-0 text-sm text-pink-700">
                            <span class="text-pink-600 hover:text-pink-800 cursor-pointer restaurant-link" data-original-name="${ restaurant.name }">${ restaurant.name }</span>
                        </td>
                        <td class="px-1 py-0 text-sm text-pink-700">${ restaurant.walking_distance_meters || 'N/A' }</td>
                        <td class="px-1 py-0 text-sm text-pink-700" data-original-cuisine="${ cuisineStr }">${ cuisineStr }</td>
                        <td class="px-1 py-0 text-sm text-pink-700">${ statusHtml }</td>
                        <td class="px-1 py-0 text-sm text-pink-700">${ restaurant.rating || 'N/A' }</td>
                    `

                    row.innerHTML = ( index === 0 ) ? `${ chargerCell }${ restaurantContent }` : restaurantContent
                    rows.push( row )
                } )
            }

            addClickHandlersToRows( rows, chargerId )
            return rows
        }

        // --- All other helper and utility functions (addClickHandlersToRows, populateCuisineFilter, showLoadingState, etc.) remain the same ---
        // (For brevity, the remaining utility functions which do not need changes are omitted, but they are present in the original file and should be kept)

        function addClickHandlersToRows ( rows, chargerId ) {
            rows.forEach( row => {
                row.querySelector( '.city-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const station = stationData.find( s => s.id === chargerId )
                    if ( station ) {
                        map.setView( station.chargerMarker.getLatLng(), 15 )
                        station.chargerMarker.openPopup()
                        bottomResults.style.display = 'none'
                        document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                    }
                } )

                row.querySelector( '.restaurant-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const restaurantName = e.target.textContent
                    const station = stationData.find( s => s.id === chargerId )
                    if ( station ) {
                        const restaurantMarker = station.restaurantMarkers.find( m => m.options.restaurantName === restaurantName )
                        if ( restaurantMarker ) {
                            map.setView( restaurantMarker.getLatLng(), 16 )
                            restaurantMarker.openPopup()
                            bottomResults.style.display = 'none'
                            document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                        }
                    }
                } )
            } )
        }

        function highlightTextInRow ( row, searchTerm, cuisineFilter ) {
            const restaurantCell = row.querySelector( '.restaurant-link' )
            if ( restaurantCell ) {
                const originalName = restaurantCell.dataset.originalName
                restaurantCell.innerHTML = searchTerm ?
                    originalName.replace( new RegExp( `(${ searchTerm })`, 'gi' ), '<mark>$1</mark>' ) :
                    originalName
            }

            const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
            if ( cuisineCell ) {
                const originalCuisine = cuisineCell.dataset.originalCuisine
                let highlightedCuisine = originalCuisine
                if ( cuisineFilter.length > 0 && !cuisineFilter.includes( '' ) ) {
                    cuisineFilter.forEach( c => {
                        highlightedCuisine = highlightedCuisine.replace( new RegExp( `(${ c })`, 'gi' ), '<mark>$1</mark>' )
                    } )
                }
                cuisineCell.innerHTML = highlightedCuisine
            }
        }

        function populateCuisineFilter () {
            const cuisines = new Set()
            stationData.forEach( station => {
                station.restaurants.forEach( r => {
                    ( r.cuisine_types || [] ).forEach( c => cuisines.add( c.trim() ) )
                } )
            } )

            const sortedCuisines = Array.from( cuisines ).sort()
            cuisineFilterButtons.innerHTML = '' // Clear previous

            const createButton = ( text, value ) => {
                const button = document.createElement( 'button' )
                button.textContent = text
                button.dataset.cuisine = value
                button.className = 'px-3 py-1 border border-pink-300 rounded-full text-sm text-pink-700 hover:bg-pink-100 transition-colors duration-200'
                return button
            }

            const allButton = createButton( 'All Cuisines', '' )
            allButton.classList.add( 'selected' )
            currentCuisineFilter = [ '' ]
            cuisineFilterButtons.appendChild( allButton )

            sortedCuisines.forEach( c => {
                cuisineFilterButtons.appendChild( createButton( c, c ) )
            } )
        }

        function clearPreviousResults () {
            routeLayer.clearLayers()
            chargerLayer.clearLayers()
            restaurantLayer.clearLayers()
            viewportSuperchargersLayer.clearLayers()
            stationData = []
            viewportSuperchargers.clear()
            lastViewportBounds = null
            filteredChargerIDs = null
            currentSearchTerm = ''
            restaurantSearchInput.value = ''
            document.getElementById( 'chargers-tbody' ).innerHTML = ''

            // Clear autocomplete session tokens
            autocompleteSessions.origin = null
            autocompleteSessions.destination = null
        }

        function showLoadingState ( message ) {
            document.getElementById( 'loading-container' ).classList.remove( 'hidden' )
            document.getElementById( 'loading-text' ).textContent = message
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
            searchForm.style.display = 'none'
            bottomResults.style.display = 'block'
            topToolbar.style.display = 'flex'
            mapElement.style.top = '60px'
            mapElement.style.height = 'calc(100vh - 60px)'
            bottomResults.style.top = '60px'
            bottomResults.style.height = 'calc(100vh - 60px)'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'
        }

        function showResultsTable () {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.remove( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
        }

        function showChargerInResults ( chargerId ) {
            bottomResults.style.display = 'block'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'
            const chargerRow = document.querySelector( `tr[data-charger-id="${ chargerId }"]` )
            if ( chargerRow ) {
                chargerRow.scrollIntoView( { behavior: 'smooth', block: 'center' } )
                chargerRow.style.backgroundColor = '#fef2f2'
                setTimeout( () => { chargerRow.style.backgroundColor = '' }, 2000 )
            }
            setTimeout( () => map.invalidateSize(), 100 )
        }

        function showEmptyState ( message ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            const noResults = document.getElementById( 'no-results' )
            noResults.textContent = message
            noResults.classList.remove( 'hidden' )
        }

        function showErrorState ( message ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            updateStatus( message, true )
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
            topToolbar.style.display = 'none'
            mapElement.style.top = '0'
            mapElement.style.height = '100vh'
        }

        async function handleLocationClick () {
            if ( !navigator.geolocation ) {
                updateStatus( "Geolocation is not supported by this browser.", true )
                return
            }
            loadingSpinner.classList.remove( 'hidden' )
            locationBtn.disabled = true
            try {
                const position = await new Promise( ( resolve, reject ) => navigator.geolocation.getCurrentPosition( resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 20000
                } ) )
                const { latitude: lat, longitude: lon } = position.coords

                // Reverse geocode the coordinates to get an address
                const address = await reverseGeocode( lat, lon )
                originInput.value = address
                updateStatus( "Location detected and set as origin.", false )
                startLocationTracking()
            } catch ( error ) {
                console.log( "Geolocation error:", error )
                let errorMessage = "Could not access your location."
                if ( error.code === error.PERMISSION_DENIED ) {
                    errorMessage += " Please enable location permissions in your browser."
                } else if ( error.code === error.POSITION_UNAVAILABLE ) {
                    errorMessage += " Location information is unavailable."
                } else if ( error.code === error.TIMEOUT ) {
                    errorMessage += " Location request timed out. Try again or check your GPS signal."
                }
                updateStatus( errorMessage, true )
            } finally {
                loadingSpinner.classList.add( 'hidden' )
                locationBtn.disabled = false
            }
        }

        function startLocationTracking () {
            if ( locationTrackingInterval ) clearInterval( locationTrackingInterval )
            document.getElementById( 'gps-btn' ).classList.remove( 'hidden' )

            const updateMarker = ( position ) => {
                const { latitude: lat, longitude: lon } = position.coords
                updateUserLocationMarker( lat, lon )
            }

            navigator.geolocation.getCurrentPosition( updateMarker, ( err ) => console.log( "Initial location error:", err ) )
            locationTrackingInterval = setInterval( () => {
                navigator.geolocation.getCurrentPosition( updateMarker, ( err ) => console.log( "Tracking location error:", err ) )
            }, 5000 )
        }

        async function updateUserLocationMarker ( lat, lon ) {
            if ( userLocationMarker ) userLocationLayer.removeLayer( userLocationMarker )

            // Create popup content with coordinates and a button to populate address
            let popupContent = `<strong>Princess Location</strong><br>Lat: ${ lat.toFixed( 6 ) }<br>Lon: ${ lon.toFixed( 6 ) }<br><button onclick="populateAddressFromLocation(${ lat }, ${ lon })" class="mt-2 px-2 py-1 bg-pink-500 text-white text-xs rounded hover:bg-pink-600">Use as Origin</button>`

            userLocationMarker = L.marker( [ lat, lon ], {
                icon: L.divIcon( {
                    className: 'princess-marker',
                    html: 'üë∏',
                    iconSize: [ 36, 36 ],
                } )
            } ).bindPopup( popupContent )
            userLocationLayer.addLayer( userLocationMarker )
        }

        function stopLocationTracking () {
            if ( locationTrackingInterval ) {
                clearInterval( locationTrackingInterval )
                locationTrackingInterval = null
            }
            if ( userLocationMarker ) {
                userLocationLayer.removeLayer( userLocationMarker )
                userLocationMarker = null
            }
            document.getElementById( 'gps-btn' ).classList.add( 'hidden' )
        }

        let debounceTimer
        function setupAutocomplete ( inputElement, suggestionsDiv ) {
            let lastInputValue = ''
            const inputId = inputElement.id // 'origin' or 'destination'

            inputElement.addEventListener( 'input', () => {
                clearTimeout( debounceTimer )
                debounceTimer = setTimeout( async () => {
                    const query = inputElement.value.trim()

                    // Clear session token if input changed significantly (less than 3 chars or completely different)
                    if ( query.length < 3 || !lastInputValue.startsWith( query.substring( 0, Math.min( 3, query.length ) ) ) ) {
                        autocompleteSessions[ inputId ] = null
                    }

                    if ( query.length < 3 ) {
                        suggestionsDiv.classList.add( 'hidden' )
                        return
                    }

                    lastInputValue = query

                    try {
                        let url = `/autocomplete?partial=${ encodeURIComponent( query ) }`
                        if ( autocompleteSessions[ inputId ] ) {
                            url += `&session_token=${ encodeURIComponent( autocompleteSessions[ inputId ] ) }`
                        }

                        const response = await fetch( url )
                        if ( !response.ok ) throw new Error( 'Autocomplete failed' )
                        const data = await response.json()

                        // Store the session token for future requests
                        if ( data.session_token ) {
                            autocompleteSessions[ inputId ] = data.session_token
                        }

                        displaySuggestions( data.predictions, suggestionsDiv, inputElement )
                    } catch ( error ) {
                        console.error( 'Autocomplete error:', error )
                        suggestionsDiv.classList.add( 'hidden' )
                    }
                }, 300 )
            } )
            inputElement.addEventListener( 'blur', () => setTimeout( () => suggestionsDiv.classList.add( 'hidden' ), 150 ) )
        }

        function displaySuggestions ( predictions, suggestionsDiv, input ) {
            suggestionsDiv.innerHTML = ''
            if ( !predictions || predictions.length === 0 ) {
                suggestionsDiv.classList.add( 'hidden' )
                return
            }
            predictions.forEach( prediction => {
                const suggestion = document.createElement( 'div' )
                suggestion.className = 'autocomplete-suggestion'
                suggestion.textContent = prediction.description
                suggestion.addEventListener( 'mousedown', () => { // Use mousedown to fire before blur
                    input.value = prediction.description
                    suggestionsDiv.classList.add( 'hidden' )
                } )
                suggestionsDiv.appendChild( suggestion )
            } )
            const inputRect = input.getBoundingClientRect()
            suggestionsDiv.style.left = `${ inputRect.left }px`
            suggestionsDiv.style.top = `${ inputRect.bottom + window.scrollY }px`
            suggestionsDiv.style.width = `${ inputRect.width }px`
            suggestionsDiv.classList.remove( 'hidden' )
        }

        // Reverse geocode coordinates to get an address
        async function reverseGeocode ( lat, lon ) {
            const apiKey = '{{.APIKey}}' // This will be replaced by the Go template
            const url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${ lat },${ lon }&key=${ apiKey }`

            try {
                const response = await fetch( url )
                const data = await response.json()

                if ( data.status === 'OK' && data.results.length > 0 ) {
                    return data.results[ 0 ].formatted_address
                } else {
                    console.warn( 'Reverse geocoding failed:', data.status )
                    // Fallback to coordinates if reverse geocoding fails
                    return `${ lat.toFixed( 6 ) }, ${ lon.toFixed( 6 ) }`
                }
            } catch ( error ) {
                console.error( 'Reverse geocoding error:', error )
                // Fallback to coordinates if API call fails
                return `${ lat.toFixed( 6 ) }, ${ lon.toFixed( 6 ) }`
            }
        }

        // Function to populate the origin input with the address from coordinates
        async function populateAddressFromLocation ( lat, lon ) {
            try {
                const address = await reverseGeocode( lat, lon )
                originInput.value = address
                updateStatus( "Address populated from current location.", false )
            } catch ( error ) {
                console.error( 'Could not populate address:', error )
                updateStatus( "Could not get address for current location.", true )
            }
        }

        setupAutocomplete( originInput, originSuggestions )
        setupAutocomplete( destinationInput, destinationSuggestions )

        document.getElementById( 'toggle-btn' ).addEventListener( 'click', () => {
            const isHidden = bottomResults.style.display === 'none'
            bottomResults.style.display = isHidden ? 'block' : 'none'
            document.getElementById( 'toggle-btn' ).textContent = isHidden ? 'Show map' : 'Show Results'
            setTimeout( () => map.invalidateSize(), 100 )
        } )

        newSearchBtn.addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.remove( 'hidden' ) )
        document.getElementById( 'cancel-new-search' ).addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.add( 'hidden' ) )
        document.getElementById( 'confirm-new-search' ).addEventListener( 'click', () => {
            stopLocationTracking()
            // Clear autocomplete session tokens
            autocompleteSessions.origin = null
            autocompleteSessions.destination = null
            window.location.href = window.location.pathname
        } )

        document.getElementById( 'toggle-cuisine-btn' ).addEventListener( 'click', () => {
            const cuisineDiv = document.getElementById( 'cuisine-filter-buttons' )
            cuisineDiv.style.display = cuisineDiv.style.display === 'none' ? 'flex' : 'none'
        } )

        document.getElementById( 'gps-btn' ).addEventListener( 'click', () => {
            if ( userLocationMarker ) {
                map.setView( userLocationMarker.getLatLng(), Math.max( map.getZoom(), 15 ) )
                bottomResults.style.display = 'none'
                document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                setTimeout( () => map.invalidateSize(), 100 )
            }
        } )

        function updateStatus ( message, isError = false ) {
            statusMessage.textContent = message
            statusMessage.className = `text-center mt-3 text-sm font-medium ${ isError ? 'text-red-600' : 'text-pink-600' }`
        }

        function updateUrlForSearch ( origin, destination ) {
            const url = new URL( window.location )
            url.searchParams.set( 'origin', encodeURIComponent( origin ) )
            url.searchParams.set( 'destination', encodeURIComponent( destination ) )
            window.history.pushState( {}, '', url )
        }

        if ( navigator.geolocation ) {
            startLocationTracking()
        }

    </script>
</body>

</html>