<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Passenger Princess Protector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        .font-dancing {
            font-family: 'Dancing Script', cursive;
        }

        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: calc(100vh - 60px);
            width: 100vw;
            position: absolute;
            top: 60px;
            margin: 0;
            padding: 0;
        }

        .overlay-form {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            z-index: 1000;
            background: rgba(255, 255, 255, .95);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, .1);
            max-height: 100vh;
            overflow: auto;
        }

        .bottom-results {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 1100;
            background: rgba(255, 255, 255, .95);
            padding: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, .1);
            display: none;
            height: calc(100vh - 60px);
        }

        #chargers-table {
            border-collapse: collapse;
            line-height: 1;
            max-height: calc(100vh - 120px);
            width: 100%;
            table-layout: fixed;
        }

        #chargers-table tr,
        #chargers-table td,
        #chargers-table th {
            height: 18px;
            line-height: 1
        }

        #chargers-table td,
        #chargers-table th {
            border-bottom: 1px solid #fbcfe8;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .autocomplete-suggestions {
            position: fixed;
            background: #fff;
            border: 1px solid #d1d5db;
            border-radius: .375rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05);
            z-index: 1100;
            max-height: 220px;
            overflow: auto;
            margin-top: 2px;
        }

        .autocomplete-suggestion {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color .15s;
        }

        .autocomplete-suggestion:hover {
            background: #f8fafc;
        }

        .emoji-icon {
            font-size: 24px;
            line-height: 1;
            text-align: center;
            text-shadow: 0 0 3px #fff, 0 0 5px #fff;
        }

        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #ec4899;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0)
            }

            100% {
                transform: rotate(360deg)
            }
        }

        mark {
            background: #fef3c7 !important;
            color: #000 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-weight: 600 !important;
        }

        .princess-marker {
            background: transparent !important;
            border: none !important;
            font-size: 36px !important;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, .3);
        }

        #location-btn.tracking-active {
            background: linear-gradient(to-r, #ec4899, #f97316);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: .8
            }
        }

        #cuisine-filter-buttons button.selected {
            background: #ec4899;
            color: #fff;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, .1);
            transform: translateY(-1px)
        }

        @media (max-width:768px) {
            .overlay-form {
                padding: 10px;
                position: fixed;
                top: 0
            }

            #chargers-table {
                font-size: 10px
            }

            #chargers-table th,
            #chargers-table td {
                padding: 4px 6px
            }
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>

<body class="bg-pink-100 font-sans antialiased">
    <div id="map"></div>

    <div id="top-toolbar"
        class="fixed top-0 left-0 right-0 z-50 bg-gradient-to-r from-pink-200 to-pink-300 border-b border-pink-400 p-3 flex justify-between items-center shadow-lg">
        <div class="text-2xl font-bold text-pink-800 font-dancing">PPP</div>
        <div class="flex space-x-2">
            <button id="gps-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-3 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200 hidden"
                title="Center on Princess">üìç</button>
            <button id="toggle-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200">Show
                Results</button>
            <button id="new-search-btn"
                class="bg-gradient-to-r from-pink-400 to-pink-500 hover:from-pink-500 hover:to-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-md hover:shadow-lg transition-all duration-200">New
                Search</button>
        </div>
    </div>

    <div class="bottom-results" id="bottom-results">
        <div id="results-list" class="px-2" style="height:100%; overflow-y:auto;">
            <div class="flex space-x-2 mb-4 pt-4">
                <input id="restaurant-search"
                    class="flex-grow px-4 py-3 border border-pink-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-pink-500 text-sm"
                    placeholder="Search restaurants or cuisines...">
                <button id="toggle-cuisine-btn"
                    class="px-3 py-3 bg-pink-400 hover:bg-pink-500 text-white rounded-md shadow-sm text-sm"
                    title="Toggle cuisine filters">Filters</button>
            </div>
            <div id="cuisine-filter-buttons" class="flex flex-wrap gap-2 mb-4" style="display:none;"></div>

            <div id="loading-container" class="loading-container hidden">
                <div class="spinner"></div>
                <p id="loading-text" class="loading-text">Finding route...</p>
            </div>

            <div style="overflow-x:auto;">
                <table id="chargers-table" class="hidden w-full">
                    <thead class="sticky top-0 bg-white z-10">
                        <tr>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-24">
                                Stop</th>
                            <th class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider">
                                Restaurant</th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-24">
                                Walk</th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-28">
                                Cuisine</th>
                            <th
                                class="px-1 py-0 text-left text-xs font-medium text-pink-500 uppercase tracking-wider w-28">
                                Rating / Open</th>
                        </tr>
                    </thead>
                    <tbody id="chargers-tbody"></tbody>
                </table>
            </div>

            <p id="no-results" class="text-pink-500">Search for a route to see results.</p>
        </div>
        <hr class="border-pink-300">
    </div>

    <div class="overlay-form" id="search-form">
        <header class="text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold text-pink-800 font-dancing">Passenger Princess Protector</h1>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-end">
            <div class="relative">
                <div class="flex items-center justify-between mb-1">
                    <label for="origin" class="block text-sm font-medium text-pink-700">Origin</label>
                    <button id="location-btn"
                        class="bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white px-3 py-1 rounded-md text-xs font-medium focus:outline-none disabled:opacity-50 whitespace-nowrap shadow-md hover:shadow-lg transition-all duration-200">
                        <span id="location-text">üë∏ Use Current Location</span>
                        <div id="loading-spinner"
                            class="hidden w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin inline-block ml-2">
                        </div>
                    </button>
                </div>
                <input id="origin"
                    class="block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm"
                    placeholder="e.g., San Francisco, CA">
                <div id="origin-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>

            <div class="relative">
                <label for="destination" class="block text-sm font-medium text-pink-700">Destination</label>
                <input id="destination"
                    class="mt-1 block w-full px-4 py-3 rounded-md border-pink-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 text-sm"
                    placeholder="e.g., Los Angeles, CA">
                <div id="destination-suggestions" class="autocomplete-suggestions hidden"></div>
            </div>

            <div class="md:col-span-2">
                <button id="find-route-btn"
                    class="w-full bg-gradient-to-r from-pink-500 to-pink-600 hover:from-pink-600 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all duration-200 text-sm hover:shadow-lg">
                    Find Route & Amenities
                </button>
            </div>
        </div>
        <div id="status-message" class="text-center mt-3 text-pink-600 font-medium text-sm"></div>
    </div>

    <div id="new-search-modal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[1200] hidden">
        <div class="bg-white rounded-lg p-6 max-w-sm mx-4 shadow-xl">
            <h3 class="text-lg font-semibold text-pink-800 mb-4 font-dancing">Are you sure?</h3>
            <p class="text-gray-600 mb-6">This will clear your current search and start a new one.</p>
            <div class="flex space-x-3 justify-end">
                <button id="cancel-new-search"
                    class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium">Cancel</button>
                <button id="confirm-new-search"
                    class="px-4 py-2 bg-pink-500 hover:bg-pink-600 text-white rounded-lg font-medium">Yes, New
                    Search</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM
        const originInput = document.getElementById( 'origin' )
        const destinationInput = document.getElementById( 'destination' )
        const findRouteBtn = document.getElementById( 'find-route-btn' )
        const statusMessage = document.getElementById( 'status-message' )
        const mapElement = document.getElementById( 'map' )
        const originSuggestions = document.getElementById( 'origin-suggestions' )
        const destinationSuggestions = document.getElementById( 'destination-suggestions' )
        const searchForm = document.getElementById( 'search-form' )
        const bottomResults = document.getElementById( 'bottom-results' )
        const topToolbar = document.getElementById( 'top-toolbar' )
        const newSearchBtn = document.getElementById( 'new-search-btn' )
        const locationBtn = document.getElementById( 'location-btn' )
        const locationText = document.getElementById( 'location-text' )
        const loadingSpinner = document.getElementById( 'loading-spinner' )
        const restaurantSearchInput = document.getElementById( 'restaurant-search' )
        const cuisineFilterButtons = document.getElementById( 'cuisine-filter-buttons' )

        // Hide toolbar until searching
        topToolbar.style.display = 'none'
        mapElement.style.top = '0'
        mapElement.style.height = '100vh'

        // --- Leaflet map
        let map = L.map( mapElement, { zoomControl: false, zoomSnap: 0.5, zoomDelta: 1 } ).setView( [ 37.7749, -122.4194 ], 6 )
        L.tileLayer( 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' } ).addTo( map )

        const routeLayer = L.layerGroup().addTo( map )
        const chargerLayer = L.layerGroup().addTo( map )
        const restaurantLayer = L.layerGroup().addTo( map )
        const userLocationLayer = L.layerGroup().addTo( map )

        let userLocationMarker = null
        let locationTrackingInterval = null
        let stationData = []          // [{ id, chargerInfo, restaurants, chargerMarker, restaurantMarkers }]
        let filteredChargerIDs = null // null = no filter; otherwise array of visible IDs
        let currentSearchTerm = ''
        let currentCuisineFilter = []

        // --- Events
        findRouteBtn.addEventListener( 'click', handleRouteSearch )
        document.getElementById( 'toggle-btn' ).addEventListener( 'click', () => {
            const isHidden = bottomResults.style.display === 'none'
            bottomResults.style.display = isHidden ? 'block' : 'none'
            document.getElementById( 'toggle-btn' ).textContent = isHidden ? 'Show map' : 'Show Results'
            setTimeout( () => map.invalidateSize(), 100 )
        } )
        newSearchBtn.addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.remove( 'hidden' ) )
        document.getElementById( 'cancel-new-search' ).addEventListener( 'click', () => document.getElementById( 'new-search-modal' ).classList.add( 'hidden' ) )
        document.getElementById( 'confirm-new-search' ).addEventListener( 'click', () => { stopLocationTracking(); window.location.href = window.location.pathname } )

        locationBtn.addEventListener( 'click', handleLocationClick )
        document.getElementById( 'gps-btn' ).addEventListener( 'click', () => {
            if ( userLocationMarker ) {
                const latLng = userLocationMarker.getLatLng()
                map.setView( latLng, Math.max( map.getZoom(), 15 ) )
                bottomResults.style.display = 'none'
                document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                setTimeout( () => map.invalidateSize(), 100 )
            }
        } )

        restaurantSearchInput.addEventListener( 'input', () => {
            filterListAndMap( restaurantSearchInput.value, currentCuisineFilter )
        } )

        cuisineFilterButtons.addEventListener( 'click', ( e ) => {
            if ( e.target.tagName !== 'BUTTON' ) return
            const cuisine = e.target.dataset.cuisine

            if ( currentCuisineFilter.includes( cuisine ) ) {
                currentCuisineFilter = currentCuisineFilter.filter( c => c !== cuisine )
                e.target.classList.remove( 'selected' )
            } else {
                currentCuisineFilter.push( cuisine )
                e.target.classList.add( 'selected' )
            }

            // 'All' handling
            if ( cuisine === '' && e.target.classList.contains( 'selected' ) ) {
                currentCuisineFilter = [ '' ]
                Array.from( cuisineFilterButtons.children ).forEach( btn => { if ( btn !== e.target ) btn.classList.remove( 'selected' ) } )
            } else if ( cuisine !== '' ) {
                const allButton = cuisineFilterButtons.querySelector( 'button[data-cuisine=""]' )
                if ( allButton ) {
                    allButton.classList.remove( 'selected' )
                    currentCuisineFilter = currentCuisineFilter.filter( c => c !== '' )
                }
            }
            if ( currentCuisineFilter.length === 0 ) {
                const allButton = cuisineFilterButtons.querySelector( 'button[data-cuisine=""]' )
                if ( allButton ) {
                    allButton.classList.add( 'selected' )
                    currentCuisineFilter = [ '' ]
                }
            }

            filterListAndMap( currentSearchTerm, currentCuisineFilter.filter( c => c !== '' ) )
        } )

        map.on( 'moveend zoomend', updateVisibleMarkers )

        // --- Autocomplete wired to /autocomplete
        let debounceTimer
        function setupAutocomplete ( inputEl, boxEl ) {
            inputEl.addEventListener( 'input', () => {
                clearTimeout( debounceTimer )
                const q = inputEl.value.trim()
                if ( q.length < 3 ) { boxEl.classList.add( 'hidden' ); return }
                debounceTimer = setTimeout( async () => {
                    try {
                        const res = await fetch( `/autocomplete?partial=${ encodeURIComponent( q ) }` )
                        if ( !res.ok ) throw new Error( 'autocomplete failed' )
                        const json = await res.json()
                        const items = json.predictions || []
                        displaySuggestions( items, boxEl, inputEl )
                    } catch ( e ) {
                        console.warn( 'autocomplete error', e )
                        boxEl.classList.add( 'hidden' )
                    }
                }, 250 )
            } )
            inputEl.addEventListener( 'blur', () => setTimeout( () => boxEl.classList.add( 'hidden' ), 150 ) )
        }
        function displaySuggestions ( predictions, boxEl, inputEl ) {
            boxEl.innerHTML = ''
            if ( !predictions || predictions.length === 0 ) { boxEl.classList.add( 'hidden' ); return }
            predictions.forEach( p => {
                const div = document.createElement( 'div' )
                div.className = 'autocomplete-suggestion'
                div.textContent = p.description || p.structured_formatting?.main_text || ''
                div.addEventListener( 'click', () => { inputEl.value = div.textContent; boxEl.classList.add( 'hidden' ) } )
                boxEl.appendChild( div )
            } )
            const r = inputEl.getBoundingClientRect()
            boxEl.style.left = `${ r.left }px`
            boxEl.style.top = `${ r.bottom + window.scrollY }px`
            boxEl.style.width = `${ r.width }px`
            boxEl.classList.remove( 'hidden' )
        }
        setupAutocomplete( originInput, originSuggestions )
        setupAutocomplete( destinationInput, destinationSuggestions );

        // --- URL auto-search
        ( function autoSearchFromUrl () {
            const url = new URL( window.location )
            const o = url.searchParams.get( 'origin' )
            const d = url.searchParams.get( 'destination' )
            if ( o && d ) {
                originInput.value = decodeURIComponent( o )
                destinationInput.value = decodeURIComponent( d )
                setTimeout( handleRouteSearch, 300 )
            }
        } )()

        // --- Main search using /route
        async function handleRouteSearch () {
            const origin = originInput.value.trim()
            const destination = destinationInput.value.trim()
            if ( !origin || !destination ) { updateStatus( 'Please enter both an origin and a destination.', true ); return }

            updateUrlForSearch( origin, destination )
            clearPreviousResults()
            showLoadingState( 'Finding route & superchargers...' )

            try {
                const res = await fetch( `/route?origin=${ encodeURIComponent( origin ) }&destination=${ encodeURIComponent( destination ) }` )
                if ( !res.ok ) throw new Error( await res.text() )
                const data = await res.json()

                // Draw main route
                if ( !data?.route?.polyline ) throw new Error( 'No polyline found for route.' )
                const coords = decodeGooglePolyline( data.route.polyline ).map( ( [ lat, lng ] ) => [ lat, lng ] )
                drawRoute( coords )
                map.fitBounds( L.polyline( coords ).getBounds().pad( 0.1 ) )

                // Build stations
                const chargers = Array.isArray( data.superchargers ) ? data.superchargers : []
                await processAndDisplayResults( chargers )

                const totalDist = data.route.total_distance || ''
                const totalDur = data.route.total_duration || ''
                updateStatus( `Route: ${ totalDist } ‚Ä¢ ${ totalDur } ‚Ä¢ ${ stationData.length } superchargers with restaurants`, false )
            } catch ( err ) {
                console.error( err )
                showErrorState( typeof err === 'string' ? err : 'Could not find a route. Please try different locations.' )
            }
        }

        async function processAndDisplayResults ( chargers ) {
            if ( !chargers || chargers.length === 0 ) { showEmptyState( 'No Superchargers near your route.' ); return }

            stationData = []
            const tbody = document.getElementById( 'chargers-tbody' )
            tbody.innerHTML = ''
            const frag = document.createDocumentFragment()

            chargers.forEach( ( sc, idx ) => {
                const chargerMarker = createChargerMarker( sc )
                const restaurantMarkers = createRestaurantMarkers( sc.restaurants || [] )
                stationData.push( {
                    id: `${ idx }`, // API doesn‚Äôt specify id; use index
                    chargerInfo: sc,
                    restaurants: sc.restaurants || [],
                    chargerMarker,
                    restaurantMarkers
                } )
                const rows = createTableRowsForStation( idx, sc, sc.restaurants || [] )
                rows.forEach( r => frag.appendChild( r ) )
            } )

            tbody.appendChild( frag )
            populateCuisineFilter()
            showResultsTable()
            updateVisibleMarkers()
        }

        function filterListAndMap ( searchTerm, cuisines ) {
            currentSearchTerm = ( searchTerm || '' ).toLowerCase()
            currentCuisineFilter = Array.isArray( cuisines ) ? cuisines.map( c => c.toLowerCase() ) : []

            const tbody = document.getElementById( 'chargers-tbody' )
            const rows = tbody.querySelectorAll( 'tr[data-charger-id]' )
            const vis = new Map() // id -> visible

            rows.forEach( row => {
                const id = row.dataset.chargerId
                const restCell = row.querySelector( '.restaurant-link' )
                if ( !vis.has( id ) ) vis.set( id, false )

                if ( restCell ) {
                    const name = restCell.textContent.toLowerCase()
                    const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
                    const original = ( cuisineCell.dataset.originalCuisine || cuisineCell.textContent || '' ).toLowerCase()
                    const restaurantCuisines = original.split( ';' ).map( s => s.trim() ).filter( Boolean )

                    const nameMatches = !currentSearchTerm || name.includes( currentSearchTerm )
                    const cuisineMatches = currentCuisineFilter.length === 0 || currentCuisineFilter.some( c => restaurantCuisines.includes( c ) )

                    if ( nameMatches && cuisineMatches ) vis.set( id, true )
                } else {
                    if ( !currentSearchTerm && currentCuisineFilter.length === 0 ) vis.set( id, true )
                }
            } )

            const visibleIds = new Set()
            rows.forEach( row => {
                const id = row.dataset.chargerId
                const isVisible = vis.get( id )
                const restCell = row.querySelector( '.restaurant-link' )
                if ( isVisible ) {
                    row.style.display = ''
                    visibleIds.add( id )
                    if ( restCell ) {
                        const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
                        const originalCuisine = cuisineCell.dataset.originalCuisine || cuisineCell.textContent
                        // highlight matches
                        if ( currentSearchTerm ) {
                            const txt = restCell.textContent
                            restCell.innerHTML = txt.replace( new RegExp( `(${ escapeRegex( currentSearchTerm ) })`, 'gi' ), '<mark>$1</mark>' )
                        } else {
                            restCell.textContent = restCell.textContent // reset
                        }
                        let high = originalCuisine
                        if ( currentCuisineFilter.length > 0 ) {
                            const toks = originalCuisine.split( ';' ).map( s => s.trim() )
                            const matched = toks.filter( t => currentCuisineFilter.includes( t.toLowerCase() ) )
                            if ( matched.length ) high = originalCuisine.replace( new RegExp( `(${ matched.map( escapeRegex ).join( '|' ) })`, 'gi' ), '<mark>$1</mark>' )
                        }
                        cuisineCell.innerHTML = high
                    }
                } else {
                    row.style.display = 'none'
                    if ( restCell ) {
                        const cuisineCell = row.querySelector( 'td[data-original-cuisine]' )
                        const originalCuisine = cuisineCell.dataset.originalCuisine || cuisineCell.textContent
                        restCell.textContent = restCell.textContent
                        cuisineCell.textContent = originalCuisine
                    }
                }
            } )

            filteredChargerIDs = ( !currentSearchTerm && currentCuisineFilter.length === 0 ) ? null : Array.from( visibleIds )
            updateVisibleMarkers()
        }

        function updateVisibleMarkers () {
            const bounds = map.getBounds()
            const zoom = map.getZoom()
            stationData.forEach( s => {
                const show = filteredChargerIDs === null || filteredChargerIDs.includes( s.id )
                const cm = s.chargerMarker
                if ( show && bounds.contains( cm.getLatLng() ) ) {
                    if ( !chargerLayer.hasLayer( cm ) ) chargerLayer.addLayer( cm )
                } else {
                    if ( chargerLayer.hasLayer( cm ) ) chargerLayer.removeLayer( cm )
                }

                const showRestaurants = show && zoom >= 14
                s.restaurantMarkers.forEach( rm => {
                    const nameOk = !currentSearchTerm || rm.options.restaurantName.toLowerCase().includes( currentSearchTerm )
                    const rcuis = ( rm.options.cuisine || '' ).toLowerCase().split( ';' ).map( c => c.trim() )
                    const cuisineOk = currentCuisineFilter.length === 0 || currentCuisineFilter.some( c => rcuis.includes( c ) )
                    if ( showRestaurants && nameOk && cuisineOk && bounds.contains( rm.getLatLng() ) ) {
                        if ( !restaurantLayer.hasLayer( rm ) ) restaurantLayer.addLayer( rm )
                    } else {
                        if ( restaurantLayer.hasLayer( rm ) ) restaurantLayer.removeLayer( rm )
                    }
                } )
            } )
        }

        function createChargerMarker ( sc ) {
            const address = sc.address || ''
            const distanceRouteM = sc.distance_from_route_meters ?? null
            const fromRoute = distanceRouteM != null ? `${ Math.round( distanceRouteM ) } m off route` : ''
            const arrival = sc.arrival_time ? `<strong>ETA:</strong> ${ sc.arrival_time }<br>` : ''
            const popup = `
        <div class="font-sans max-w-xs">
          <strong class="text-lg">${ escapeHtml( sc.name || 'Tesla Supercharger' ) }</strong><br>
          <strong>Address:</strong> ${ escapeHtml( address ) }<br>
          ${ arrival }
          ${ fromRoute ? `<strong>Offset:</strong> ${ fromRoute }<br>` : '' }
          <button onclick="showChargerInResults('${ sc.__idx || 0 }')" class="bg-pink-500 hover:bg-pink-600 text-white text-sm px-2 py-1 rounded mt-2 mr-2">View in Results</button>
          <a href="https://maps.google.com/?q=${ sc.lat },${ sc.lng }" target="_blank" class="text-pink-500 hover:underline text-sm">Open in Google Maps</a>
        </div>`
            const m = L.marker( [ sc.lat, sc.lng ], {
                icon: L.divIcon( { className: 'emoji-icon', html: '‚ö°Ô∏è', iconSize: [ 24, 24 ] } )
            } ).bindPopup( popup )
            return m
        }

        function createRestaurantMarkers ( rests ) {
            return rests.map( r => L.marker( [ r.lat, r.lng ], {
                icon: L.divIcon( { className: 'emoji-icon', html: 'üå≠', iconSize: [ 24, 24 ] } ),
                restaurantName: r.name || '',
                cuisine: ( r.cuisine_types || [] ).join( '; ' )
            } ).bindPopup( `<strong>${ escapeHtml( r.name || 'Restaurant' ) }</strong><br>${ Math.round( r.walking_distance_meters || 0 ) } m away` ) )
        }

        function drawRoute ( coords ) {
            L.polyline( coords, { color: 'hotpink', weight: 5, opacity: .7 } ).addTo( routeLayer )
        }

        function createTableRowsForStation ( idx, sc, restaurants ) {
            const rows = []
            const leftCell = `
        <td class="px-1 py-0 text-sm text-pink-500 border-r border-pink-200" rowspan="${ restaurants.length || 1 }">
          <div class="flex flex-col">
            <span>${ escapeHtml( sc.name || 'Supercharger' ) }</span>
            <span class="text-xs text-pink-600 hover:text-pink-800 cursor-pointer city-link">${ escapeHtml( sc.address || '' ) }</span>
          </div>
        </td>
      `

            if ( ( restaurants || [] ).length === 0 ) {
                const tr = document.createElement( 'tr' )
                tr.dataset.chargerId = `${ idx }`
                tr.innerHTML = `${ leftCell }<td class="px-1 py-0 text-sm text-pink-700" colspan="4">No restaurants found</td>`
                rows.push( tr )
            } else {
                restaurants.forEach( ( r, i ) => {
                    const tr = document.createElement( 'tr' )
                    tr.dataset.chargerId = `${ idx }`
                    tr.dataset.restaurantName = r.name || ''
                    const cuisineStr = ( r.cuisine_types || [] ).join( '; ' )
                    const ratingOpen = `${ r.rating != null ? r.rating.toFixed( 1 ) : '‚Äì' } / ${ r.is_open_now ? 'Open' : 'Closed' }`
                    const restCells = `
            <td class="px-1 py-0 text-sm text-pink-700">
              <span class="text-pink-600 hover:text-pink-800 cursor-pointer restaurant-link">${ escapeHtml( r.name || '' ) }</span>
            </td>
            <td class="px-1 py-0 text-sm text-pink-700">${ Math.round( r.walking_distance_meters || 0 ) }m</td>
            <td class="px-1 py-0 text-sm text-pink-700" data-original-cuisine="${ escapeHtml( cuisineStr ) }">${ escapeHtml( cuisineStr ) }</td>
            <td class="px-1 py-0 text-sm text-pink-700">${ escapeHtml( ratingOpen ) }</td>
          `
                    tr.innerHTML = i === 0 ? `${ leftCell }${ restCells }` : restCells
                    rows.push( tr )
                } )
            }

            // Bind clicks
            rows.forEach( row => {
                row.querySelector( '.city-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const st = stationData.find( s => s.id === `${ idx }` )
                    if ( st ) {
                        map.setView( st.chargerMarker.getLatLng(), 15 )
                        st.chargerMarker.openPopup()
                        bottomResults.style.display = 'none'
                        document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                    }
                } )
                row.querySelector( '.restaurant-link' )?.addEventListener( 'click', ( e ) => {
                    e.stopPropagation()
                    const name = e.target.textContent
                    const st = stationData.find( s => s.id === `${ idx }` )
                    if ( st ) {
                        const m = st.restaurantMarkers.find( mk => mk.options.restaurantName === name )
                        if ( m ) {
                            map.setView( m.getLatLng(), 16 )
                            m.openPopup()
                            bottomResults.style.display = 'none'
                            document.getElementById( 'toggle-btn' ).textContent = 'Show Results'
                        }
                    }
                } )
            } )

            return rows
        }

        function populateCuisineFilter () {
            const cuisines = new Set()
            stationData.forEach( s => ( s.restaurants || [] ).forEach( r => ( r.cuisine_types || [] ).forEach( c => c && cuisines.add( c ) ) ) )
            const sorted = Array.from( cuisines ).sort( ( a, b ) => a.localeCompare( b ) )
            cuisineFilterButtons.innerHTML = ''

            const mkBtn = ( label, val ) => {
                const b = document.createElement( 'button' )
                b.textContent = label
                b.dataset.cuisine = val
                b.className = 'px-3 py-1 border border-pink-300 rounded-full text-sm text-pink-700 hover:bg-pink-100 transition-colors duration-200'
                return b
            }

            const allBtn = mkBtn( 'All Cuisines', '' )
            allBtn.classList.add( 'selected' )
            currentCuisineFilter = [ '' ]
            cuisineFilterButtons.appendChild( allBtn )
            sorted.forEach( c => cuisineFilterButtons.appendChild( mkBtn( cap( c ), c ) ) )
            cuisineFilterButtons.parentElement.style.display = sorted.length ? 'block' : 'none'
        }

        function showChargerInResults ( chargerId ) {
            bottomResults.style.display = 'block'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'
            const row = document.querySelector( `tr[data-charger-id="${ chargerId }"]` )
            if ( row ) {
                row.scrollIntoView( { behavior: 'smooth', block: 'center' } )
                row.style.backgroundColor = '#fef2f2'
                setTimeout( () => row.style.backgroundColor = '', 2000 )
            }
            setTimeout( () => map.invalidateSize(), 100 )
        }

        function clearPreviousResults () {
            routeLayer.clearLayers(); chargerLayer.clearLayers(); restaurantLayer.clearLayers()
            stationData = []; filteredChargerIDs = null; currentSearchTerm = ''
            restaurantSearchInput.value = ''
            document.getElementById( 'chargers-tbody' ).innerHTML = ''
            stopLocationTracking()
        }

        function showLoadingState ( msg ) {
            document.getElementById( 'loading-container' ).classList.remove( 'hidden' )
            document.getElementById( 'loading-text' ).textContent = msg
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
            searchForm.style.display = 'none'
            bottomResults.style.display = 'block'
            topToolbar.style.display = 'flex'
            mapElement.style.top = '60px'
            mapElement.style.height = 'calc(100vh - 60px)'
            bottomResults.style.top = '60px'
            bottomResults.style.height = 'calc(100vh - 60px)'
            document.getElementById( 'toggle-btn' ).textContent = 'Show map'
        }
        function showResultsTable () {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.remove( 'hidden' )
            document.getElementById( 'no-results' ).classList.add( 'hidden' )
        }
        function showEmptyState ( msg ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            const p = document.getElementById( 'no-results' ); p.textContent = msg; p.classList.remove( 'hidden' )
        }
        function showErrorState ( msg ) {
            document.getElementById( 'loading-container' ).classList.add( 'hidden' )
            document.getElementById( 'chargers-table' ).classList.add( 'hidden' )
            updateStatus( msg, true )
            searchForm.style.display = 'block'
            bottomResults.style.display = 'none'
            topToolbar.style.display = 'none'
            mapElement.style.top = '0'
            mapElement.style.height = '100vh'
        }
        function updateStatus ( message, isError = false ) {
            statusMessage.textContent = message
            statusMessage.className = `text-center mt-3 text-sm font-medium ${ isError ? 'text-red-600' : 'text-pink-600' }`
        }
        function updateUrlForSearch ( origin, destination ) {
            const u = new URL( window.location )
            u.searchParams.set( 'origin', encodeURIComponent( origin ) )
            u.searchParams.set( 'destination', encodeURIComponent( destination ) )
            window.history.pushState( {}, '', u )
        }

        // --- Location helpers (unchanged UI, no API deps)
        async function handleLocationClick () {
            if ( locationTrackingInterval ) { stopLocationTracking(); updateStatus( 'Location tracking stopped.', false ); return }
            locationText.textContent = 'Getting location...'
            loadingSpinner.classList.remove( 'hidden' ); locationBtn.disabled = true
            try {
                const pos = await new Promise( ( res, rej ) => navigator.geolocation.getCurrentPosition( res, rej, { enableHighAccuracy: true, timeout: 10000 } ) )
                const { latitude: lat, longitude: lon } = pos.coords
                originInput.value = `${ lat.toFixed( 6 ) }, ${ lon.toFixed( 6 ) }`
                updateStatus( 'Location detected and set as origin.', false )
                startLocationTracking()
                locationText.textContent = 'üë∏ Tracking Active'
                locationBtn.classList.add( 'tracking-active' )
            } catch ( e ) {
                console.log( 'Geolocation error', e )
                updateStatus( 'Could not access your location.', true )
            } finally {
                loadingSpinner.classList.add( 'hidden' ); locationBtn.disabled = false
            }
        }
        function startLocationTracking () {
            if ( locationTrackingInterval ) clearInterval( locationTrackingInterval )
            document.getElementById( 'gps-btn' ).classList.remove( 'hidden' )
            navigator.geolocation.getCurrentPosition(
                ( pos ) => updateUserLocationMarker( pos.coords.latitude, pos.coords.longitude ),
                () => { },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
            )
            locationTrackingInterval = setInterval( async () => {
                try {
                    const pos = await new Promise( ( res, rej ) => navigator.geolocation.getCurrentPosition( res, rej, { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 } ) )
                    updateUserLocationMarker( pos.coords.latitude, pos.coords.longitude )
                } catch { }
            }, 5000 )
        }
        function updateUserLocationMarker ( lat, lon ) {
            if ( userLocationMarker ) userLocationLayer.removeLayer( userLocationMarker )
            userLocationMarker = L.marker( [ lat, lon ], { icon: L.divIcon( { className: 'princess-marker', html: 'üë∏', iconSize: [ 36, 36 ] } ) } )
                .bindPopup( `<strong>Princess Location</strong><br>Lat: ${ lat.toFixed( 6 ) }<br>Lon: ${ lon.toFixed( 6 ) }` )
            userLocationLayer.addLayer( userLocationMarker )
        }
        function stopLocationTracking () {
            if ( locationTrackingInterval ) { clearInterval( locationTrackingInterval ); locationTrackingInterval = null }
            if ( userLocationMarker ) { userLocationLayer.removeLayer( userLocationMarker ); userLocationMarker = null }
            document.getElementById( 'gps-btn' ).classList.add( 'hidden' )
            locationText.textContent = 'üë∏ Use Current Location'
            locationBtn.classList.remove( 'tracking-active' )
        }

        // --- Utilities
        function cap ( s ) { return s ? s.charAt( 0 ).toUpperCase() + s.slice( 1 ) : s }
        function escapeHtml ( s ) { return ( s ?? '' ).replace( /[&<>"']/g, m => ( { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ m ] ) ) }
        function escapeRegex ( s ) { return s.replace( /[.*+?^${}()|[\]\\]/g, '\\$&' ) }

        // Google encoded polyline decoder -> [[lat,lng],...]
        function decodeGooglePolyline ( str ) {
            let index = 0, lat = 0, lng = 0, coords = []
            while ( index < str.length ) {
                let b, shift = 0, result = 0
                do { b = str.charCodeAt( index++ ) - 63; result |= ( b & 0x1f ) << shift; shift += 5 } while ( b >= 0x20 )
                const dlat = ( ( result & 1 ) ? ~( result >> 1 ) : ( result >> 1 ) )
                lat += dlat
                shift = 0; result = 0
                do { b = str.charCodeAt( index++ ) - 63; result |= ( b & 0x1f ) << shift; shift += 5 } while ( b >= 0x20 )
                const dlng = ( ( result & 1 ) ? ~( result >> 1 ) : ( result >> 1 ) )
                lng += dlng
                coords.push( [ lat * 1e-5, lng * 1e-5 ] )
            }
            return coords
        }

        // Auto-start lightweight location tracking if already granted
        window.addEventListener( 'load', () => setTimeout( async () => {
            if ( !navigator.geolocation ) return
            try {
                const pos = await new Promise( ( res, rej ) => navigator.geolocation.getCurrentPosition( res, rej, { enableHighAccuracy: true, timeout: 3000, maximumAge: 30000 } ) )
                startLocationTracking()
                locationText.textContent = 'üë∏ Tracking Active'
                locationBtn.classList.add( 'tracking-active' )
                const { latitude: lat, longitude: lon } = pos.coords
                originInput.value = `${ lat.toFixed( 6 ) }, ${ lon.toFixed( 6 ) }`
            } catch { }
        }, 800 ) );
    </script>
</body>

</html>